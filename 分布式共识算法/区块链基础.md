## 比特币

### 1.密码学中的hash

密码学中的hash有两个重要性质：抗碰撞性，hiding（隐藏输入），puzzle friendly。

抗碰撞性要求，比如你用hash函数给一个message加密，生成一个hash保存起来，结果别人把这个message给改了，用hash函数hash出来的结果还和之前一样，这样就不是有效加密的hash函数。要保证输入中的数据任何一个改动都会让hash值变的不同，这就是hash的抗碰撞性。但是没有什么证明能证明哪个hash函数是绝对抗碰撞的，只能让时间证明。MD5就没有经得起时间的检验。

hiding就是要求hash函数能够隐藏输入，不能根据hash结果反推出来原本的输入数据是什么，比如比特币用的SHA256，就是不管输入的数据是什么，都生成256位的hash值，输入可以是一个小数字，也可以是一个10GB的数据。SHA256的目的是hash，而不是加密，加密你后面是需要解秘的，要保证信息的完整性，但是hash函数不是，是为了让你拿不到输入，是可以丢失信息的，如果SHA256能反推出来，那这就像一个压缩算法了。

puzzle friendly，想要得到一个hash结果前几位都是0的数字，没有方法只能暴力。比特币中的应用就是对交易message取hash，再对hash值进行签名。

私钥 经过hash ->公钥 经过hash ->地址。

**问题** 公私钥如何生成的？

### 2.数据结构

类比传统的链表，你改动链表中的一个数据，那么改了就改了，不会对链表有任何影响。区块链中的区块，是用hash指针连接的，hash指针说的就是后一个区块保存的是前一个区块的hash，只是保存hash，因为hash函数的抗碰撞性，你改了一个区块的数据，其他任何一个节点都是不承认的。所以对于轻节点，只需要保存最近几千个区块。

每个block包括 block header和block body，block body存储的是block中的所有交易，这些交易也是由hash指针组成的一棵Merkle Tree，header会存储merkle tree的root hash。轻节点只存储block的header，而且比特币的hash指针只对区块的header取hash。

实际上，比特币中的hash指针，只有hash，没有指针，全节点会把区块链保存到kv数据库里面，常用的是levelDB，所谓的区块链是hash->区块存到levelDB里的，在levelDB里面用hash查到区块，区块里又有前一个hash的指针，就可以把完整的区块链查出来。

block header包括的数据有：version，前hash指针，merkle root hash，target，nonce。

### 3.double spending

央行发行货币会怎么发？也需要带有各种防伪标志，数字货币发行出来只是一个文件的形式，那么如何保证一个货币不会花两次，在比特币中，由于没有余额的设计，是存在双花攻击的，比如A对B发起来一笔转账，然后A又指向同样的数据来源再给自己发起一笔交易，这样，如果A给自己发的交易被包含在区块中称为了最长合法链中的一个交易，那么A给B的转账就作废，如果A给B的转账已经形成了某种现实的好处，这就没办法了。简单的方式就是：多等几个确认，刚出的区块还是比较容易被篡改的，比特币默认6个，也就是要等1个小时。

另外，比特币中的每一个交易都是包括输入和输出的。输入是币的来源和A的公钥，输出是收钱人的地址，因为A转给B，其他的节点需要用A的公钥验证这个输入到底是不是给A的，所以，这种转账方式有什么麻烦的地方？假设A的来源是10个比特币，它想给B3个，那么这笔交易就应该有两个输出，一个是B的地址一个是A的地址。

### 4.挖矿

比特币唯一非发币方式：挖矿，最开始每出一块就是50BTC，21万个区块之后减半，再过21万个区块就是12.5BTC。每隔2016个区块调整一次挖矿难度，让挖矿保持在大概10min出一个区块。但是现在也没有证明这种方式就是最优的。

但是，如果出块时间调的太小，比如10s出一个区块，那么这个分叉的概率就会更高，因为出块快也说明出块更容易，这样的话，恶意节点攻击就会更加容易，后面说的51%攻击也不需要达到51，可能百分之十几就可以攻击了。但也没有理论证明10min出一个区块就是最优解。

比特币底层是个P2P网络，也就是区块如何传播，现在区块的大小协议规定是1M字节。

目前比特币挖矿用的都是ASIC矿机，算力集中在少部分人手里，所以在后面以太坊都做了改进，不过改了普通人也没法参与，用gpu挖矿。比特币挖矿是对cpu要求高，指令就那么几条，但是以太坊的挖矿方式对内存有一定的要求。

### 5.分叉

分叉分为 state fork（不是故意分）  和 protocal fork（因为比特币协议改变发生的分叉）。

 protocal fork分为硬分叉和软分叉，硬分叉比如，区块的大小改变了，从接收1M改成了接收小于4M，那么因为分布式网络本来就不可能在发布协议修改的瞬间达成完全的一致，还有就是比特币网络中的节点有的就是不同意修改规则，比如把区块改大这事儿，有的节点觉得区块太大对于P2P网络是一种压力，对网络传输没好处。

区块网络可能出现的一种情况就是：一部分修改了规则的节点，既接收4M区块也接收1M区块，成为最长合法链，另一部分不接受修改规则的节点，认为最长合法链包含大于1M的区块是不合法的，就在自己认为是合法的链上继续挖，其实这种就相当于是两种币了。

还有就是，你同一笔钱在上下两条链上花了两次怎么办？比特币的解决方法是在这两条链上带了一个chainID。

软分叉：比如区块的大小改成0.5M了，那么，接受了修改规则的大部分节点在之后只挖0.5M的区块，那么不接受协议修改的部分节点，他们接收小于1M的区块，也就是软分叉是老的协议兼容新的协议，那么不改规则的节点继续挖1M的区块，但是小于1M的区块链才是最长合法链，所以对于软分叉来说非常惨，因为它挖出来它自己都不认是最长合法链。

selfish mining：正常矿工挖一个区块发一个，恶意节点挖出来多个区块不发，比如目前最新发布了5个区块，但我藏了6个，但是这要求恶意节点的算力在50%以上，分叉攻击。

### 6.UTXO

全节点维护utxo，前面说的double spending就可以用utxo查出来。另外，区块链是可以有共享账户的，可以多重签名。另外，比特币的共识并不是真正意义上的分布式共识。

比特币是永远不可能成为真正货币的，稀缺性资源不适合做货币，因为它的总量一定比消耗的快。

### 7.分布式共识理论

不可能结论：

FLP：在一个异步系统里，网络延迟无上限，即便有一个节点是错误的，就无法共识。

CAP：任何一个分布式系统，只能同时满足三个中的两个，一致性、可用性、容错性。

paxos：保证一致性，但客观上paxos会可能永远都达不到一致性。



## 以太坊

设计基础：如果货币都可以去中心化，还有什么可以去中心化，以太坊的设计就是通过技术手段把司法合约的职能给取代了，虽然不是所有的合约都可以量化，去中心化的合约有什么好处？比现实的好处？智能合约的好处是不可更改，而且如果合约的参与方是来自多个国家，没有统一的司法机构对合约进行监管。

### 1.余额

比特币的设计没有余额的概念，都是同utxo来看一笔交易的输入是否合法，但是以太坊账户是有余额的设计的，这样的好处是：没有double spending，因为不会有人主动把自己的钱给扣两次，但是有replay attack，就是交易的接收人在收到一笔转账之后，再向网络中广播一次，同一笔交易让矿工打包两次，所以以太坊的设计里面多了nonce。

### 2.账户

以太坊的账户有两种：

1.外部账户（余额，nonce交易次数）

2.合约账户（不能发交易，合约之间可以调用次数，包括code和状态）

以太坊的设计比较符合我们常规的使用思想，有余额，发交易的时候不用指明钱是哪来的，也不需要把剩下的余额再转给自己。以太坊共识GHOST，共识时间很短，这样的话分叉概率是很高的，它的分叉确实很频繁，如果不能成为最长合法链，对于用户来说是非常不友好的，所以它的设计增加了叔夫区块。







