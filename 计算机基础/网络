### 一、应用层 

#### 1.  浏览器中输入URL地址到显示网页的过程

1.输入url：在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的url，然后给出智能提示，让你可以补全url地址。对于google的浏览器，他会直接从缓存中把网页展示出来，就是说，你还没有按下enter，页面就出来了。

2.如果输入的是域名，如果是直接的ip就没有这一步。

浏览器会首先查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的ip 地址。

如果在本地的hosts文件没有能够找到对应的ip地址，浏览器会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。

查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，如果没有的话，本地域名服务器就会以一个client的身份迭代的向DNS根服务器进行查询、授权域名服务器发起查询，返回一个结果。

本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果。

3.浏览器向Web服务器发送一个http请求

拿到IP地址后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求，这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。

这个过程一般还要经过路由转发，常见的路由协议有rip和ospf，rip是定期把向邻居发送自己的全部路由表，ospf是向全网发送自己和邻居节点的链路信息，那么在同一个局域网中，还需要arp协议把ip地址转换成对应的物理地址，最终以0 1比特在物理链路上传输。

建立了TCP连接之后，发起一个http请求。一个典型的http request header 一般需要包括请求的方法，例如GET 或者POST 等，一般的浏览器只能发起GET或者POST 请求。客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：

| 请求方法URI协议/版本；

| 请求头(Request Header)；

| 请求正文

4.服务器处理请求

后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。

一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。

5.服务器返回HTTP相应

HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：

l 　状态行

l 　响应头(Response Header)

l 　响应正文

HTTP/1.1 200 OK

Date: Sat, 31 Dec 2005 23:59:59 GMT

Content-Type: text/html;charset=ISO-8859-1

Content-Length: 122

＜html＞

＜/html＞

6.浏览器显示html

在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样。

反正如果http协议是长连接，可以在一个tcp连接里面把资源都加载了，如果是短连接的话还要分别发起请求。

 

#### 2.HTTP有哪些请求方法？它们的作用或者说应用场景？

GET: 请求指定的页面信息，并返回主体。

HEAD: 和GET类似，只不过不返回报文主体，只返回响应首部。可用于确认URI的有效性及资源更新的日期时间。

POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。

PUT: 用来传输文件，要求请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。

DELETE: 删除URI指定的资源，但是无法保证一定会被执行，因为http允许服务器在不通知客户端的情况下撤销请求。

OPTIONS: 用来查询对请求URI这个资源支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息。

TRACE: 会在目的服务器端发起一个“回环”诊断，我们都知道，客户端在发起一个请求时，这个请求可能要穿过防火墙、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送服务器时，它变成了什么样子。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请

CONNECT: 使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

 

#### 3、get和post有什么区别？

（1）post比安全安全一点点，虽然两个都是明文传输，但是get的url会被放到浏览器历史和web服务器日志里，post不会被缓存发完就没了，但是如果被抓包了，那什么都没用，还是一样的不安全。也是因为get的url会被缓存，我们在浏览器输入一个url的时候大多数浏览器都能智能提示，但你不能手打个post请求出来。

（3）一般来说，对于无状态的重复的操作，比如获取个数据，就用get，不可以重复的操作，比如修改新增就用post，所以get是幂等的，但post不是。

（4）GET可以发送的参数只能是ASCII类型，POST没有限制，甚至可以传输二进制

（5）HTTP的底层是TCP/IP。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。GET/POST都是TCP链接。不过Get产生一个Tcp数据包，Post产生两个Tcp数据包，对于Get方式的请求，浏览器会把http header和data一起发出去服务器响应200 OK（返回数据）；而对于Post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK（返回数据）。

#### 4.说说http协议

http，超文本传输协议，是应用层上的一种客户端/服务器模型的通信协议，它由请求和响应构成，是无状态的。

![屏幕快照 2019-09-11 下午2.43.16](/Users/didi/Desktop/屏幕快照 2019-09-11 下午2.43.16.png)

Request

|  请求行：请求方法，URL，协议版本

|  请求头：头部键，值（这个部分一般会有好几行）

|  请求体：请求数据

![屏幕快照 2019-09-11 下午2.51.35](/Users/didi/Desktop/屏幕快照 2019-09-11 下午2.51.35.png)

Response

l 　状态行（协议版本、状态码、状态描述符）

l 　响应头(Response Header)

l 　响应正文

![屏幕快照 2019-09-11 下午2.52.26](/Users/didi/Desktop/屏幕快照 2019-09-11 下午2.52.26.png)

请求和响应常见的通用头：

Content—type：请求体/响应体的类型，比如text/plain，application/json
Accept：说明接收的类型，可以用多个值
Content-length：请求体/响应体的长度，单位字节
Content-encoding：请求体/响应体编码格式比如gzip
Accept-encoding：告知对方我方接受的content-encoding。

#### 5.HTTP常见的状态码？

- 1XX：信息性状态码，表示接收的请求正在处理
- 2XX：成功状态码，表示请求正常处理完毕
- 3XX：重定向状态码，表示需要进行附加操作以完成请求
- 4XX：客户端错误状态码，表示服务器无法处理请求
- 5XX：服务端错误状态码，表示服务器处理请求出错

常见的状态码有：

​       100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

- 200 OK，请求被正常处理
- 301 Move Permanently，永久性重定向
- 302 Found，临时性重定向
- 400 Bad Request，请求报文中存在语法错误
- 403 Forbidden，对请求资源的访问被服务器拒绝
- 404 Not Found，在服务器上不能找到请求的资源
- 500 Internal Server Error，服务器内部错误
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

#### 6.Http和Https的区别

http是超文本传输协议，用于在万维网上可靠的交换文件，运行在TCP协议之上，Https就是在Http之上加入了SSL协议的加密能力，SSL工作在传输层和应用层之间，为数据加密。比如用RSA非对称加密的方式。

Https主要分为两个部分：首先是Https的握手，然后是数据的传输，前者建立Https的通道，并确定连接使用的加密套件以及数据传输使用的密钥，后者主要使用密钥对数据加密传输。

非对称加密就是说，在tcp建立连接后，要先使用ssl协议向双方发送要如何加密，然后才进行真正的交互，非对称加密就是说，在发消息之前，双方先把公钥发给对方，比如A给B发送消息，那么A会用B的公钥给消息加密，然后B收到之后用B的私钥对消息进行解密。而且非对称加密还引入了CA，就是证书颁发机构，是说，如果A和B在交换公钥的过程中，在路上被人篡改了怎么办？那就加入了CA，只有CA签发的证书才是有效的。服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证了身份的合法，解决了公钥获取的安全性。

#### 7.Http1.0和1.1的区别

1.长连接和短连接：

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection :close；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。

2.流水线

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

#### 8.Http1.1的新特性

- 默认是长连接
- 支持流水线
- 支持同时打开多个 TCP 连接
- 支持虚拟主机
- 新增状态码 100
- 支持分块传输编码
- 新增缓存处理指令 max-age

#### 9.Http2.0的新功能

1.X一些做不到的事情：不会压缩请求和响应的首部，这样也会在一定程度上增大网络的负载，客户端往往需要使用多个连接才能拿到所有要获取的数据。

报文的格式改了，在2.0中报文被分成了HEADERS frame和DATA frame。HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

### 二、传输层

#### 1.tcp两次握手不行吗？

tcp三次握手的两个目的：信息对等和防止超时。
从信息对等的角度来看，假设是A机器先发送给B机器，B机器给了确认。如果到这里两次握手结束，那B机器实际上是不知道自己的发报能力是否正常，也不知道A机器接受报文的能力是否正常。并不能保证是全双工通信状态。
防止超时是为了防止出现请求超时导致脏链接。TTL网络报文的生存时间往往都会超过TCP链接请求时间，如果两次握手就可以创建链接传输数据并释放链接后，第一个超时请求才达到B机器，B会给这个超时的请求建立链接，但A因为状态不是SYN_SENT，就直接丢弃。导致建立脏链接。

#### 2.tcp三次握手的几个状态

A机器发送了SYN=1的链接建立请求，此时A机器状态是SYN_SENT，B机器收到是SYN-RCVD，B再发出SYN确认和链接建立请求，A收到之后就是链接建立，发回确认，B再处于established状态。

#### 3.tcp四次挥手

当A想要关闭链接，先发送FIN信号给B，此时A处于（FIN-WAIT-1），B应答ACK，A处于（FIN-WAIT-2），A处于半关闭状态，无法发送数据。B机器做好链接关闭前准备工作后，发送FIN给机器A，此时B也进入半关闭状态，A机器针对B的FIN，ACK之后进入TIME-WAIT状态，经过2MSL，没有再收到B的报文，则判断B已经收到了A的ACK，链接正式释放。

#### 为什么挥手之后还要再等2MSL

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。如果客户端不等待立即CLOSED，客户端就不能对服务端的FIN = 1进行确认,如果在2MSL内客户端都没有收到服务端的任何消息，便认为服务端收到了确认。此时可以结束TCP连接。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

#### 4.TCP和UDP的区别

传输层功能：不同主机上的进程间的逻辑通信，提供两种不同的传输协议。

UDP：无连接，尽最大努力交付，面向报文，对应用层交下来的报文不拆分，一次发一个报文，无拥塞控制，首部开销校，（8字节）首部有8B，源端，目的端，长度，校验和。校验：采用首部，伪首部，数据进行二进制反码运算再取反。

 TCP：面向连接，可靠交付，一对一全双工通信，面向字节流，根据发送窗口以及拥塞窗口的大小决定一次发多大的报文。首部20B，连接管理：三次握手建立，四次握手释放

#### 5.TCP可靠传输如何实现

可靠传输实现：序号，保证数据有序
​              确认：期待下次收到的报文段第一个字节的序号
​              重传，发生超时或者冗余确认

TCP如何实现可靠传输？
应用数据被分割成TCP认为最适合发送的块进行传输。
超时重传，TCP发出一个分组后，它启动一个定时器，等接收方确认收到这个分组。如果发送方不能及时收到一个确认，将重传给接收方。
序号，用于检测丢失的分组和冗余的分组。
确认，告知对方已经正确收到的分组以及期望的下一个分组。
校验和，校验数据在传输过程中是否发生改变，如校验有错则丢弃分组。
流量控制，使用滑动窗口，发送窗口的大小由接收窗口和拥塞窗口的的大小决定（取两者中小的那个），当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
拥塞控制，当网络拥塞时，减少数据的发送。

流量控制说的都是：让发送方别发太快，要让接收方来得及接收
拥塞控制：如果网络中的结点都处于来不及接收分组要大量丢弃的时候，网络就处于拥塞状态。
拥塞控制：原理，根据估算的网络拥塞程度设置发送窗口的大小
​         方法： 慢开始：发送窗口< 慢开始门限时，收到一个确认发送窗口乘2
​                  拥塞避免：发送窗口> 慢开始门限时，收到一个确认发送窗口+1
​                  快重传:收到三个ACK，直接重传
​                  快恢复：收到三个ACK，慢开始门限=发送窗口/2
​         拥塞处理：慢开始门限设置为发送窗口/2，发送窗口置1

#### 6.主机A向主机B发送数据，在这个过程中，传输层和网络层做了什么？

当TCP连接建立之后，应用程序就可使用该连接进行数据收发。应用程序将数据提交给TCP，TCP将数据放入自己的缓存，数据会被当做字节流并进行分段，然后加上TCP头部并提交给网络层。再加上IP头后被网络层提交给到目的主机，目的主机的IP层会将分组提交给TCP，TCP根据报文段的头部信息找到相应的socket，并将报文段提交给该socket，socket是和应用关联的，于是数据就提交给了应用。

对于UDP会简单些，UDP面向报文段。传输层加上UDP头部递交给网络层，再加上IP头部经路由转发到目的主机，目的主机将分组提交给UDP，UDP根据头部信息找到相应的socket，并将报文段提交给该socket，socket是和应用关联的，于是数据就提交给了应用。

#### 7.三次握手和四次挥手

1.客户端TCP向服务器TCP发送一个连接请求报文段，SYN=1，客户机会随机选择一个序号seq=x。2.服务器收到TCP连接以后，如同意连接，向客户机发确认，为TCP连接分配TCP缓存和变量，SYN和ACK都置1，确认号为x+1,并随机产生起始序号seq=y。3.客户端收到后还要再给出确认，并且给TCP分配缓存和变量。确认报文段ACK置1，序号为seq=x+1,确认号字段ack=y+1.

四次挥手：
1.客户端打算关闭连接，向TCP发送连接释放报文段，并停止再发送数据，主动关闭TCP连接，FIN=1，seq=u（上一个字节序号+1）（这时候客户端已经不能再发送了，但对方还可以再发）。2.服务器收到后发出确认，确认号ack=u+1，seq=v（前面传送过的最后一个字节的序号+1），此时客户端到服务器的链接就释放了，但服务器要发数据的话，客户端还是要接收。3.服务器没有要发的，就发送FIN=1链接释放报文，ack=1，ack=u+1，seq=w。
4.客户端发出确认，ack=1，ack=w+1，seq=u+1，再过2MSL ，进入链接关闭状态。



这些状态里面哪些多了是说明有问题？



#### 8.cookie和session区别和联系？

cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上。他可以用来做用户的标志，让服务器知道当前是哪个用户。

Session是在服务端存在的一种概念，它可以用来跟踪用户的状态，比如刚才说的cookie可以做用户的标志，让服务器知道是哪个用户，cookie也是实现seesion的一种方式，从应用上来说，不如分布式session，可以在用户登陆后给他一个token，之后浏览器每次请求都带着token，然后服务器维护一个token和用户的对应列表，我们就可以知道当前的用户是谁。
session的运行依赖session id，而session id是存在cookie中的，也就是说，如果浏览器禁用了cookie ，同时session也会失效（但是可以通过url重写，即在url中传递session_id）。

#### 9.为何使用session？session的原理？

Session原理：浏览器第一次访问服务器时，服务器会响应一个cookie给浏览器。这个cookie记录的就是sessionId，之后每次访问携带着这个sessionId，服务器里查询该sessionId，便可以识别并跟踪特定的用户了。比如分布式环境下，我们可以在一个用户登陆进系统之后，给他生成一个token，服务器的redis存储一个token和user对应的列表，每次用户跳转都带着sessionid，这样服务器就可以识别。

Cookie原理：第一次访问服务器，服务器响应时，要求浏览器记住一个信息。之后浏览器每次访问服务器时候，携带第一次记住的信息访问。相当于服务器识别客户端的一个通行证。Cookie不可跨域，浏览览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie，换句话说Google只能操作Google的Cookie。

#### 10.mtu最大传输单元

mtu中文名称最大传输单元，他是放在数据链路层的一个概念，因为mtu存在，就限制了上层发送数据的大小。

比如说我发送的ip数据包在往外网发送的时候，超过了路由器限制的1500，那么路由器就会给你分片，但是如果你的ip数据包标志着不允许拆包，那路由器就直接给你扔了。

#### 11.TCP首部

![屏幕快照 2019-09-12 上午9.34.23](/Users/didi/Desktop/屏幕快照 2019-09-12 上午9.34.23.png)



- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。



#### 12.UDP首部

![](/Users/didi/Desktop/屏幕快照 2019-09-12 上午9.34.35.png)

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

DNS：把特定含义的主机名转换成IP。运行在UDP协议之上，使用53端口
FTP：允许用户在互联网上获取文件。运行在TCP之上，控制链接21号端口，数据连接20号端口。采用C/S模式，使用TCP可靠传输。
控制链接与数据连接：FTP在工作时使用两个并行的TCP连接，一个是控制连接（21）一个是数据连接（20）。客户端通过控制链接发给服务器的控制进程，服务器的控制进程在收到FTP客户发来的文件传输请求后创建数据连接。
FTP是什么IO模型？



万维网WWW
HTML：超文本标记语言，文档结构标记语言，使用约定的标记对页面上的各种信息进行描述。万维网是一个资料空间，里面所有的资源都有一个URL，这些资料通过HTTP传给使用者。
DHCP：动态主机配置协议，从服务器动态获取IP地址，子网掩码，默认网关地址，DNS服务器名称，主机广播发现报文，DHCP服务器利用提供报文进行响应，主机利用请求报文请求IP地址，DHCP服务器分配IP地址，DHCP确认报文。DHCP是应用层协议，封装到UDP数据报中，
ICMP：互联网控制报文协议，支持主机或路由器，差错报告，网络探寻。对ICMP差错报告报文不在发送ICMP差错报告报文除第一个IP数据报分片外，对所有后续分片均不发送ICMP差错报告报文。对多播IP数据报不发送

 

 

### 三、网络层

#### 1.路由算法：

层次路由：因特网将整个互联网划分成许多个较小的自治系统（一个自治系统里包含很多局域网）每个自治系统来决定本系统采用何种路由协议。如果两个自治系统需要通信，就需要层次路由在两个自治系统之间屏蔽差异。

因特网把路由协议分为两类：内部网关协议（IGP）（自治系统内部使用）例如：RIP，OSPF。自治系统之间选择使用的路由协议是外部网关协议（EGP），也称为域间路由选择，例如：BGP。

RIP：距离向量路由选择协议，定期与邻居交换自己的全部路由表。RIP是应用层协议，使用UDP传数据。（网络中每一个路由器都要维护自己到其他每一个目的网络的距离，仅和邻居路由器交换信息，它限制了网络的规模，因为最大距离不超过15）

OSPF:链路状态路由算法，路由器向所有路由器发相邻结点的链路状态，（RIP是定期就发不管变不变），OSPF是网络层协议，使用IP数据报传送。（而且如果到同一个目的网络有多条路径，OSPF会把通信量分配给这几条链路，实现负载均衡。还可以实现分层，分为局部区和主干区，链路状态通告只限于区域内部，路由器掌握区域内部详细拓扑，只知道去往其他网络的方向。）

 BGP：边界网关协议，不通过自治系统路由器之间交换路由信息的协议。路由表包含已知路由器的列表，路由器能够到达的地址以及到达每个路由器的路径的跳数。BGP采用的是路径向量路由选择协议，BGP是应用层协议，它是基于TCP的，寻找的并非最佳路由

 工作原理：每一个自治系统至少选择一个或多个作为该自治系统的“BGP发言人”，一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要先建立TCP连接，在此连接上建立BGP会话，交换路由信息，就可以找到达到各个自治系统的比较好的路由。每一个发言人还要可以运行该AS所使用的内部网关协议。

#### 2.IP协议

IP报文格式，共 32 位 4 个字节

![屏幕快照 2019-09-11 下午3.37.20](/Users/didi/Desktop/屏幕快照 2019-09-11 下午3.37.20.png) 

- **版本** : 有 4（IPv4）和 6（IPv6）两个值；

- **首部长度** : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。

- **区分服务** : 用来获得更好的服务，一般情况下不使用。

- **总长度** : 包括首部长度和数据部分长度。

- **生存时间** ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。

- **协议** ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。

- **首部检验和** ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。

- **标识** : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。

- **片偏移** : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

  ![屏幕快照 2019-09-12 上午9.38.37](/Users/didi/Desktop/屏幕快照 2019-09-12 上午9.38.37.png)

NAT：实现专用网络地址和公用网络地址之间的转换
ARP：查询IP对应的物理地址
DHCP：给网络中的主机动态分配IP地址
ICMP：给主机或路由器报告差错和异常情况

路由器：可以用来连接异构网络，完成路由转发，能隔离冲突域和广播域，依照IP地址进行转发。
移动IP：移动节点以固定的网络IP地址，实现跨越不同网段的漫游功能

IPv4和IPv6的区别：
IPv4中IP地址长度为32，而6有128,6的地址分配从一开始就遵循了聚类的原则，6的路由表更小。

#### 3.各种播

单播(unicast):传输目的地址为单一目标的一种传输方式。通常所使用的网络协议或服务大多采用单播传输，例如，一切基于TCP的协议。
组播(multicast): 也叫多播，多点广播或群播。指把信息同时传递给一组目的地址。发送者和每一接受者之间实现点对多点网络连接，使用UDP协议，使用D类地址。
广播(broadcast):是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。
任播(anycast):是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。

 

### 四、数据链路层

负责从物理链路上直接相连的两个结点传送数据，为网络层提供服务。
介质访问子层：为使用介质的每一个结点隔离同一信道上的其他结点所传送的信号。
信道划分：频分复用：
​         时分复用：
​         波分复用：
​         码分复用：
随机访问：CSMA/CD,CSMA/CA，CSMA，ALOHA
轮询访问：令牌传递协议，只有得到令牌的协议才能发送，其他必须等待

#### 以太网

目前使用最广泛的局域网，它提供不可靠的无连接服务，以太网的MAC协议采用二进制指数退避算法的CSMA/CD

CSMA/CD :载波监听多路访问/冲突检测
1.从网络层接收数据报，常见数据帧
2.监听信道。如果网卡监听到信道空闲，就开始发送帧，如果监听到信道繁忙就一直等待直到信道空闲，然后发送帧。
3.网卡发送完整个帧，没有检测到其他结点的数据发送，就认为发送成功。
4.如果在发送的过程中检测到了其他结点发送数据，就终止发送，并发送一个堵塞信号，加强冲突。
5.终止发送后，网卡进入二进制指数退避算法。
第k次连续冲突后，取n=Max（k，10）,网卡从0——2^(n-1)次方中随机选择一个数M再继续。

 

### 五、物理层

物理层考虑的是怎样才能在连接各个计算机的传输媒体上传输数据的比特流。
信道可以分为：单工，只有一个方向的通信，没有反方向的交互
​              半双工，通信双方都可以发送，接收信息，但不能同时              
​              全双工，通信双方可以同时发送，接收信息

#### 1.OSI参考模型

物理层：在链接计算机的介质上传输0 1比特流，实现比特流的透明传输。
数据链路层：负责从物理链路上直接相邻的两个节点传送数据，为网络层提供服务，传送MAC帧。
网络层：链接异构网络，通过路由选择算法为报文或者分组选择适当的转发路径。
传输层：不同主机间进程的逻辑通信，向用户提供端到端的差错和流量控制，保证报文可靠传输。
会话层：向两个实体的表示层提供建立和使用连接的方法。
表示层：处理用户信息的表示问题，比如编码格式转换。
应用层：用户与网络的接口，引用层采用不同的协议解决不同类型的应用要求。

TCP/IP 和OSI参考模型的比较：相同：都采用分层的体系结构，基于独立的协议栈的概念，都可以解决异构网络的互连。
差别：OSI定义了服务，协议，和接口，TCP/IP 没有对这些有明确的区分。OSI通用性良好，TCP/IP先有协议，模型是对已有协议的描述。OSI在网络层支持无连接和面向连接，在传输层仅有面向连接，而TCP/IP有网络层仅有无连接，传输层有面向连接和无连接。
