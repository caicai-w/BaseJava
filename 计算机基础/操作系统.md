### 1.操作系统的启动
OS一开始放在硬盘上的
BIOS：基本I/O处理系统，主要功能是一按电源，让系统检查各种外设，检查完外设，加载软件。
还有一个BootLoader：加载OS，能够让我们的os从硬盘放到内存，这个BootLoader也在硬盘上，BootLoader在硬盘的第一个扇区（512字节），BootLoader具体放在哪由BIOS决定。
BootLoader把OS加载到内存之后，就从把执行权给了OS

### 2.进程的声明周期
创建，运行，等待，唤醒，结束
三态五态七态：
就是就绪，等待，运行三态 引入挂起后分为 ：静止就绪，活动就绪，静止阻塞，活动阻塞，运行五态 引入创建和撤销后分为 ：静止就绪，活动就绪，静止阻塞，活动阻塞，运行，创建，撤销七态
进程可以看成由资源和线程组成。

### 3.进程和线程:
进程是资源分配的单位，线程是CPU调度的单位，线程只有必不可少的资源，比如程序计数器。
进程由状态，线程同样也有就绪，阻塞执行三种状态。
线程能减少并发执行的时间和空间开销。切换快，共享数据方便，不需要切换内核，只需要地址就可以访问到。
为什么切换快：因为属于同一个进程的线程他们有同一个页表，在切换的时候，不需要切换，但是切换进程页表也要切换，很多硬件信息都需要重新加载。

线程的实现：
1.	用户线程：在用户内存空间，OS看不到，只能看到他对应的进程，由用户线程库管理。缺点：线程发出一个阻塞性的系统调用，会让整个进程等待。程序在运行时有CPU，但是比如一个中断过来之后，CPU的控制权就又落到OS手里了，（特别是时钟中断），OS会有一个强制的切换。
用户线程和内核线程有多对一，一对一，多对多的关系
2.	内核线程：OS管理。TCB是放在内核里面的，CPU的调度单位就是线程，进程就管资源了，只要完成一次线程的切换，就要有一次用户态到内核态的切换。
3.	轻量级进程：他是内核支持的用户线程，一个进程可以有多个轻量级进程，每个量级进程由一个独立的内核线程来支持。
进程和作业:
作业是用户需要计算机完成一个任务要求计算机做的工作的集合,进程是已提交的作业的执行过程,作业现在外存的后备队列等待执行,进程是完成用户任务的执行实体,一个作业可以由多个进程组成.
进程的状态转换:
进程的基本状态有运行,就绪,阻塞,影响的事件有 时间片用完(运行转就绪),等待事件(运行转阻塞),等待条件发生(阻塞转就绪)以及进程调度(就绪转运行).

进程的控制:
对所有进程实施有效的管理,创建进程,撤销进程,进程的阻塞与唤醒.进程的控制由原语实现,是由机器指令构成的,
P原语(阻塞原语)的功能是将进程由执行状态转为阻塞状态，V（唤醒）原语是将进程由阻塞转为就绪状态。一个进程期待的事件尚未出现时就调用阻塞原语把自己阻塞起来。

阻塞原语操作如下：
停止当前进程的运行，中断处理器。
保存该进程的CPU现场，以便后续从断点开始执行。
停止当前进程的运行，状态由执行转为阻塞，插到相应的等待队列。
转到进程调度程序，从就绪队列中选一个新的执行
对处于阻塞状态的进程，它等待的事件出现后，由发现的人（一般发现者与被唤醒进程是合作的并发进程）调用唤醒原语来唤醒阻塞进程。

唤醒原语操作如下：
将被唤醒的进程从相应等待队列移出。将状态改为就绪并插入相应就绪队列。


### 4.进程通信
指进程之间信息的交换。互斥和同步只是一种低级的通信方式，P、V原语也可以称为两条低级通信原语。
高级通信可以分3类：共享存储器系统，消息传递系统，管道通信（一个共享文件）。

线程：
用户线程：操作系统看不到的线程，用户线程库管理。内核线程：OS管理
用户线程和内核线程的对应关系：多对一，一对一，多对多
处理器调度
1.	高级调度（作业调度）：按照一定原则从外存上处于后备状态的作业中选择一个或多个，给他们分配内存，输入输出等必要资源，并建立相应进程使该作业具有竞争CPU的权利。
2.	中级调度：按照给定的策略，将处于外存对换区中具备运行条件的进程调入内存，或将处于内存中暂时不能运行的进程交换到外存对换区。主要内存管理与扩充。
3.	低级调度（进程调度），按照某种策略，从就绪队列中选一个进程分配给它处理器。
进程调度的方法:抢占式和非抢占式.时间片轮转也是抢占式的调度方法.
周转时间：从作业提交到执行完成的时间间隔。带权周转时间：作业周转时间比运行时间

### 5.常见调度算法
先来先服务，短作业优先，优先级调度算法，时间片轮转（进程调度独有），多级队列调度（进程调度），多级反馈队列调度（进程）

同步与互斥：
同步的概念：多个相互合作的进程在一些关键点上可能需要互相等待或互相交换信息，这种制约关系是进程同步。

1.两种形式的制约关系：间接相互制约（互斥）
保持进程同步的方法:进程间同步的主要方法有原子操作、信号量机制、管程、会合、分布式系统等。

什么是临界区？如何解决冲突？
（1）如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；
（2）任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；
（3）进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；（4）如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。

临界资源与临界区：临界资源是一种系统资源，需要不同进程互斥的去访问，但需要访问临界资源的进程一般不只有一个，所以需要临界区去控制，临界区是属于对应进程的，是每个进程中访问临界资源的一段代码，临界区还需要进入区和退出区进程检查和恢复。

死锁：
死锁是指多个进程因为竞争资源或者是顺序推进不当而永久阻塞的状态，如果没有外力作用这些进程都无法向前推进。
产生死锁的必要条件：（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能被其他进程强行夺走；（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

产生的原因：资源不足和不当的推进顺序.

死锁的处理策略：鸵鸟策略、预防策略（破坏四个必要条件中的某几个）、避免策略（在动态分配的过程中，防止系统进入不安全状态）、检测与恢复策略（在检测到之后，可以用强制剥夺资源的方式）。

死锁的预防：不剥夺，对于一个已经获得了一些资源的进程，如果申请的资源得不到满足就立即释放。但是这会造成前段时间做的工作全部白费。  请求和保持，一个进程在运行之前一次性申请完所有需要的资源，未满足之前，不投入运行。   环路等待：将所有资源按序编号，进程申请系统资源时按照序号申请，这样不会产生环路。

死锁的避免：在动态分配的过程中，预知系统是否会进入不安全状态，如果可能产生死锁，则不进行这种分配，银行家算法。

死锁的检测与解除：检测到死锁发生再采取措施。

为什么要有用户态和内核态
由于需要限制不同的程序之间的访问能力, 防止他获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态 和 内核态
内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序。
用户态: 只能受限访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取
用户态与内核态的切换
所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统。
用户态切换到内核态的方式：
1.系统调用，应用程序主动向OS发出一条指令，需要OS为他提供服务，是用户态进程主动申请切换为内核态，用户态的进程需要操作系统为他提供某种服务，比如一个printf语句。API，Java的API不是系统调用。
2.异常，在CPU运行用户态程序的时候，发生了一些预料之外的异常，就会使当前运行进程切换到处理此异常的内核相关的程序，比如缺页中断。
3.外围设备中断，当外围设备完成用户的请求操作之后，会向CPU发出相应的中断信号，这时CPU会停止当前执行的程序去响应中断，如果之前执行的是用户态的程序，这个转换就发生了用户态到内核态的切换，比如硬盘读写操作完成，系统会切换到硬盘读写操作完成后续操作。
为什么应用程序不能直接访问外设：因为OS是一个可信任的程序，而应用程序不能保证安全。我们也希望操作系统能够向上提供统一的接口，屏蔽底层设备的差异性，让应用程序变的通用，可移植。
三种的区别：
1.	来源
2.	处理时间，中断（异步），就是不知道什么时候产生。异常（同步），执行到某一特定指令，一定会发生，比如/0.系统调用（同步或异步），应用发出请求后，一直等待，那么就是同步的过程。如果发出请求之后，去做别的事情了，那么这返回的时间点就是异步的
3.	响应：中断，对应用程序是透明的。异常：可能产生异常的程序被停止，或重新执行等等。系统调用：等待服务，继续执行
中断
是操作系统正常功能的一部分，因进程调度停止当前运行的进程转而执行其他进程。使CPU中断正在运行的程序，而转到为响应的服务程序去处理。
异常是由错误引起的，比如进程越界，异常会引起中断，但中断未必是异常引起的。
网卡中断，来了一个数据包 
调用一个应用程序 和 系统调用的区别：
调用函数时，在一个栈空间完成参数传递，参数返回。而系统调用，我们的应用程序和操作系统内核拥有各自的堆栈，所以系统调用之后，应用程序还需要切换堆栈，和用户态到内核态的转换。



内存管理
CPU寄存器
缓存
内存（掉电消失）
磁盘（虚拟内存，通过分页这种）
功能：
内存的分配和回收；地址变换，把程序当中的逻辑地址转换成物理地址；内存扩充，为用户提供比内存更大的空间，实现逻辑上扩充内存的目的；内存保护，保证进入内存的各道作业都在自己的存储空间运行，互不干预。
1.抽象（只用访问逻辑地址空间，但真实的内存和硬盘是物理地址空间）2.保护（各个程序不互相干扰）3.共享（几个进程访问相同内存）4,虚拟化（交换技术）
MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求。

应用程序的编译，链接与装入
编译程序把源代码编译为若干个目标模块，通过链接程序把各个模块以及库函数链接在一起行成完整的装入模块，最后，通过装入程序装入内存。
（多个模块的都是从0号单元开始编地，链接的时候把他们混在一起，从0开头的只有一个）



链接方式：
静态链接：程序运行之前，链接成一个完整 完完整整 的模块，以后都不能再拆开。
装入时动态链接：在装入内存时，边装入边链接。
运行时动态链接：在运行的过程中，需要哪个模块 接哪个。

装入方式：
绝对装入：在编译的时候就产生物理地址。
静态重定位（可重定位装入）：根据内存当前的情况，将整个装入模块装到适当位置，地址变换通常在装入时一次完成，之后不再改变。它要求每次都给他分配连续的存储区，如果空间不足就不能执行，而且执行之后不能移动。
动态重定位：装入内存后都保持相对地址，要执行的时候再做转换。依靠硬件地址变换机构。
简单的方法是利用一个基址寄存器，加上这里面的值得到正确的物理地址。

交换技术：暂时不用的程序和数据移到外存，处理器三级调度的中级调度就是采用交换技术，对挂起也可采用交换。

内存的分配 之 连续分配管理方式：
1.	单一连续分配：
适用于单用户单任务，把内存分成两个连续存储区，一个分给os，一个分给用户。采用静态分配，适合单道程序，作业一旦进入主存就必须等到结束才能释放。内存中意运行一道作业。
2.	固定分区分配：
内存划分为若干固定大小的分区，每个分区装入一道程序，分区大小可以不等，但必须事先确定，在运行时不改变。通常采用动态重定位装入方式内存，不能实现多进程共享存储区，会产生内部碎片。
3.	动态分区分配：
也成为可变式分区分配，在作业装入主存时，根据作业大小动态建立分区，使分区的大小刚好满足作业需要，系统中分区的数目是可变的，大小也是可变的。
动态重定位分区分配加了拼接技术，剩余没有足够大的空间时拼接一个大的。
分区分配算法：
首次适应算法：按照地址递增的顺序串成一个队列，每次从队首查找找到足够大的空闲分区，画出来一块给请求者。保留了高地址的大空闲区，但是低地址有许多外部碎片。
下次适应：也称循环首次适应，缺点是缺少大的分区。
最佳适应：按照容量大小递增串成一个队列，每次都把能满足分配的最小内存分给它，但这样会产生很多外部碎片，好处是保留了大分区。
最差适应：按照容量大小递减串成一个队列，每次划分最大的，但是这样会让真正的大作业到来的时候没办法运行。

总：分区分配的动态管理：
以上说的分配方式都要求作业必须连续存放，比如一个50K的作业，必须放到一个连续的50K空间，即使现在有一个20K和30K的空闲区也不能运行。就需要对分区进行管理了，目前两种分区重定位方式：
拼接技术：把内存中无法利用的小的存储空间拼接成一个大的。
固定分区分配中存在内部碎片，动态分区分配存在外部碎片。


内存的分配 之 非 连续分配管理方式：

基本分页存储管理方式：允许一个作业存放到许多不相邻的分区中，那么就可以避免拼接，从而解决外部碎片。
将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。优缺点：
有点：内存利用率高，实现离散分配，无外部碎片，一个程序不必连续存放。
缺点：需要硬件支持，有内部碎片，共享困难，要求程序全部装入内存，没有足够的内存，程序就不能执行

分段存储管理方式：
把自己的作业按照逻辑关系分为若干个段，段是信息的逻辑单位，有完整的意义。每段都是从0开始编号，有自己的名称和长度。
没有内碎片，外碎片可以通过内存紧缩来消除；便于实现内存共享。缺点与页式存储管理的缺点相同，进程必须全部装入内存。
两种方式的比较：
相同：离散的分配方式，且都是通过地址变换机构实现地址变换。
分页仅仅是处于系统管理的需要，页大小固定且由系统决定，段的长度不固定，长度决定于用户所编写的程序，目的是为了满足用户的需要，通常由编译系统在对源程序进行编译时根据信息的性质来划分。
一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。页式系统地址空间是一维的，即单一的线性地址空间，程序员只需利用一个标识符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。
基本段页式存储管理方式：
作业的地址空间被划分为若干个逻辑分段，每段都有自己的段号，再把各个段划分为若干个大小固定的页，主存空间的管理和分页管理一样，分成若干个和页面大小相同的块，对主存的分配以块为单位。  每个进程由一个段表，每个分段有一张页表。

段页式结合了段式和页式的优点，克服了段式的外部碎片问题，但是 页式存储管理方式下平均一个程序由半页碎片，段页式管理方式下平均一段就有半页碎片，而一个程序往往有很多段，所以平均下来段页式的内部碎片比页式要多很多。

虚拟内存管理：
只将程序的一部分装入内存，其余放在外存上，就可以启动程序，（部分装入），在执行的过程中发现访问的信息不存在时再由操作系统调入内存，另一方面，可以将不使用的内容放到外存上，从而腾出空间，存放要调入的信息。
根据程序局部性原理：效果很好。
请求分页存储管理方式：
在普通分页的基础上加了，部分装入和缺页中断的功能，注意普通的是必须一次性装入主存才能运行的。
页面置换算法：先进先出，最近最少使用，时钟置换，
交换技术：
当内存空间不够时或有不够的危险时换出。交换区的大小必须足够大来存放所有用户进程的所有内存进程的拷贝。
覆盖于交换的区别：覆盖只发生在相互之间没有调用关系的程序模块之间，因为程序员必须给出程序内的各个模块之间的逻辑覆盖结构，交换是以内存中的程序大小为单位来进行的。







