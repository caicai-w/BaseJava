## 操作系统

### 1.操作系统的启动

BIOS，基本I/O处理系统，主要功能是一按电源，让系统检查各种外设，检查完外设，加载软件。干的第一个事情，就是从一个固定的地址开始，CS和IP形成一个具体的内存地址，CS是段寄存器，IP是   、加电自检，检查包括：键盘、鼠标、disk、外设这都都是bois初始化检查。

接下来就是把BootLoader从硬盘加载到内存，BootLoader，是加载OS，能够让我们的os从硬盘放到内存，这个BootLoader也在硬盘上，BootLoader在硬盘的第一个扇区（512字节），BootLoader具体放在哪由BIOS决定。BootLoader把OS加载到内存之后，就从把执行权给了OS。

 

### 2.操作系统的Interface

1. 中断，面向I/O

2. 面向应用程序，是系统调用和异常

什么是系统调用：就是应用程序给os发一个服务请求，是应用程序主动发出来的，比如你输入一个printf()，比如打开文件，关闭文件，发网络包，都是系统调用。

什么是异常，就是应用程序产生一个他意想不到的错误，比如做了个/0的操作，也有可能是恶意程序，比如访问别人的地址空间，这是需要被截获的。

什么是中断，来源于不同的外设和网络的中断（比如网络包来了），需要os给他一些处理。问题：那键盘一变敲击一遍显示，这中断岂不是很频繁？？？

 为什么应用程序不能直接操作IO：因为os是一个值得信任的程序，会提供安全的支持，还有就是可以屏蔽这些设备的不同实现，给应用程序提供简单的接口。

 三个的对比：产生的源头不同，处理时间不同，中断是异步时间点，异常是同步时间点，就是执行到了一个错误的语句那一定会出错。还有就是回复的时间是异步的。响应状态不同，中断来说，打断了当前正在执行的应用程序，但是对用户来说是无感知的，但是异常产生，你可能应用程序就出错了退出了，对于系统调用，那就是等待系统调用完成之后继续执行。

#### 2.1中断的具体处理过程

key中断号  ->   对应处理地址。

收到中断之后，查中断服务历程的地址。这只是简单的说法，实际上你一个中断打断了现在正在执行的用户进程。

异常不太一样，你一定会感知到的，而且可能是产生异常其实不一定是软件的问题，也有可能是os的某些操作没提供好，比如，你用电脑的时候，有时候某个应用程序就说卡住了，退出了，什么的，然后会有一个弹框问你要不要上报？所以有时候os也会给你重新执行那条出错的指令，对于这样的情况，应用进程也不知道哪条会出错。

系统调用是个接口，比如一个printf会触发一个系统调用，屏幕就是一个系统调用。比如Linux，Mac还有Unix他们会有一个Posix的api，就是一个通用的可移植的系统调用，操作系统来给你做跨平台。但是java 的api不是系统调用，最底层还是看是win还是mac操作系统他们提供的api是什么。

 

#### 2.2用户态内核态

用户态，当用户程序处于用户态，他有很多操作是受限制的。系统调用和函数调用的区别：是在一个栈空间完全参数传递和返回。

内核态，就是这个状态下的cpu可以执行任何指令，

 

 

### 3.内存管理

接着下面os启动起来之后做什么呢？

内存的层次结构：寄存器cache（这是cpu保存的，os是不管的），主存（掉电消失），硬盘（速度慢，容量大）

os对地址空间管理的作用：我在编写的时候不需要考虑内存，它爱给我啥地址就给我啥地址，进程之间需要隔离空间，你总不能给我的东西又给了别人，如果有共享内存访问，你要给我协调好，还有，有的程序现在不执行，os就要把它给替换出去，提供一个比内存实际空间更大的空间。

#### 2.1 地址空间和地址生成

物理地址空间，就是和物理内存直接对应的。逻辑地址空间，一般都是每一段程序都是从0开始的连续地址，逻辑地址空间都是一纬的，Linker会把多个程序连接在一起，组成的也是用逻辑地址空间表示。

cpu在执行指令是要拿到物理地址的，他会用逻辑地址做一个到物理地址的转换，是用cpu里面mmu会查找逻辑地址的映射表，会去内存里面的map去找。

os需要确保每一个进程可以访问的区域，不允许超出长度。Cpu执行的时候会查一个map，看看能不能访问，不能访问就要抛异常。

#### 2.2 连续分配管理方式

分区分配算法：

首次适应算法：按照地址递增的顺序串成一个队列，每次从队首查找找到足够大的空闲分区，画出来一块给请求者。保留了高地址的大空闲区，但是低地址有许多外部碎片。

下次适应：也称循环首次适应，缺点是缺少大的分区。

最佳适应：按照容量大小递增串成一个队列，每次都把能满足分配的最小内存分给它，但这样会产生很多外部碎片，好处是保留了大分区。

最差适应：按照容量大小递减串成一个队列，每次划分最大的，但是这样会让真正的大作业到来的时候没办法运行。

以上说的分配方式都要求作业必须连续存放，比如一个50K的作业，必须放到一个连续的50K空间，即使现在有一个20K和30K的空闲区也不能运行。就需要对分区进行管理了，目前两种分区重定位方式：拼接技术：把内存中无法利用的小的存储空间拼接成一个大的。固定分区分配中存在内部碎片，动态分区分配存在外部碎片。

#### 2.3 请求分段存储管理

把自己的作业按照逻辑关系分为若干个段，段是信息的逻辑单位，有完整的意义。每段都是从0开始编号，有自己的名称和长度。段的地址就是二维的，一个是段号一个是段偏移。段表存储的重要信息有段表的起始地址，和段表的长度。

#### 2.4 请求分页存储管理方式

分页是一个进程对应多个页，物理内存的存储单元是页框，页框的大小和页是一样的，页表来做映射，操作系统为每个进程维护一个页表，页表给出进程的每一页对应的页框的位置，和页的起始地址，这样用页内偏移就可以继续算出实际地址。当在执行的过程中引用到了不存在的页，就回有缺页中断，接下来操作系统就会确定数据在磁盘的位置，从内存中拿一个空的页框把数据加载进来，更新页表。

在这个过程中，又涉及到如果没有空的页框，又需要页替换算法，比如最近最少使用。

优点：内存利用率高，实现离散分配，无外部碎片，一个程序不必连续存放。缺点：需要硬件支持，有内部碎片，共享困难。 

MMU是内存管理单元，里面TLB，是一个缓存，缓存的就是经常访问的页表，cpu得到一个逻辑地址，先从TLB里面查。如果TLB没有，就只能查页表。TLB缺失不会很大，一个页是4k，TLB有4K，你访问4K才有缺失，还可以，再加上程序都有局部性原理。分级页表的好处是什么？比如你一个页表，在内存中没有对应，页表的标志位是0，如果是多级，那这个二级页表就不会存，坏处就是查询的次数多了。

**两种方式的比较：**

相同：离散的分配方式，且都是通过地址变换机构实现地址变换。

分页仅仅是处于系统管理的需要，页大小固定且由系统决定，段的长度不固定，长度决定于用户所编写的程序，目的是为了满足用户的需要，通常由编译系统在对源程序进行编译时根据信息的性质来划分。

页式系统地址空间是一维的，即单一的线性地址空间，程序员只需利用一个标识符，即可表示一个地址，前几位是页的号，用页的大小✖页号，再加上偏移量就可以。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。

#### 2.5 基本段页式存储管理方式

作业的地址空间被划分为若干个逻辑分段，每段都有自己的段号，再把各个段划分为若干个大小固定的页，主存空间的管理和分页管理一样，分成若干个和页面大小相同的块，对主存的分配以块为单位。  每个进程有一个段表，每个分段有一张页表。 段页式结合了段式和页式的优点，克服了段式的外部碎片问题，但是页式存储管理方式下平均一个程序由半页碎片，段页式管理方式下平均一段就有半页碎片，而一个程序往往有很多段，所以平均下来段页式的内部碎片比页式要多很多。


#### 2.6 页面置换算法

缺页中断发生的时候，如果内存满了，就需要进行一个替换。先进先出，最近最少使用，时钟置换。   
先进先出：只有FIFO算法可能出现Belady 异常，就是分配的页面数增多但缺页率反而提高的异常现象，因为fifo和用户进程访问的设计不太一样，不遵循局部性原理。 

最近最少使用：利用局部性原理，当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。

时钟置换：简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。在做页替换的时候，每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0，如果遇到使用位为0的就替换。


### 3.进程管理

#### 3.1 进程和线程

进程是资源分配的单位，线程是CPU调度的单位，线程只有必不可少的资源，比如程序计数器。进程由状态，线程同样也有就绪，阻塞执行三种状态。

线程能减少并发执行的时间和空间开销。切换快，共享数据方便，不需要切换内核，只需要地址就可以访问到。为什么切换快：因为属于同一个进程的线程他们有同一个页表，在切换的时候，不需要切换，但是切换进程页表也要切换，很多硬件信息都需要重新加载。

#### 3.2 线程的实现

1. 用户线程：用户线程的创建、切换等等都是在用户态完成的，如果这些线程可以自己执行，是不需要用户态到内核台的切换的，os只能看到他对应的进程，由用户线程库管理。缺点：线程发出一个阻塞性的系统调用，会让整个进程等待。程序在运行时有CPU，但是比如一个中断过来之后，CPU的控制权就又落到OS手里了，（特别是时钟中断），OS会有一个强制的切换。用户线程和内核线程有多对一，一对一，多对多的关系

2. 内核线程：由操作系统内核直接调用、切换的线程，调度器会把这些线程映射到各个处理器上，TCB是放在内核里面的，CPU的调度单位就是线程，进程就管资源了，只要完成一次线程的切换，就要有一次用户态到内核态的切换。一般不会直接使用内核线程，而是使用内核线程的一种高级接口：轻量级进程。

3. 轻量级进程：轻量级进程就是我们通常所说的线程，每个轻量级进程都由一个内核支持，因为只有先支持内核线程，才能有轻量级进程，由于内核线程的支持，每个轻量级进程都称为一个独立的调度单元，轻量级进程不好的地方在于：各种线程的操作，都需要系统调用在用户态和内核态来回切，而且一个轻量级进程都需要一个内核线程的支持，所以一个系统内的轻量级进程数量是有限的。

4.用户线程和轻量级进程混合实现：用户线程如果需要系统调用就让轻量级进行来完成。

#### 3.3 cpu调度

进程的生命周期：三态、五态、七态。
就是就绪，等待，运行三态
引入挂起后分为 ：静止就绪，活动就绪，静止阻塞，活动阻塞，运行，五态
引入创建和撤销后分为 ：静止就绪，活动就绪，静止阻塞，活动阻塞，运行，创建，撤销，七态。

进程的调度一般分为抢占式和非抢占式，常见的调度算法有：  
先来先服务
时间片轮转
短作业优先
最高响应比优先
轮训
多级反馈队列：分为多个队列，每个队列按照队列中任务的优先级排序，队列中的每个进程分配一个时间片，如果时间片结束还没有执行完，就要把任务放到下一级优先级队列的队尾。


#### 3.4 进程通信 同步

1.管道通信：只支持半双工通信，单向交替传输，只能在父子进程中使用。

2.信号量：用于为多个进程提供对共享数据对象的访问。

3.共享的存储区：允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。需要使用信号量用来同步对共享存储的访问。多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

4.套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信。

指进程之间信息的交换。互斥和同步只是一种低级的通信方式，P、V原语也可以称为两条低级通信原语。高级通信可以分3类：共享存储器系统，消息传递系统，管道通信（一个共享文件）。


#### 3.5 进程同步

1.临界区：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

2.同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

3.信号量

4.管程： 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

#### 3.4 临界区

什么是**临界区**？如何解决冲突？

（1）如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；

（2）任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；

（3）进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；（4）如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。

 **临界资源与临界区：**临界资源是一种系统资源，需要不同进程互斥的去访问，但需要访问临界资源的进程一般不只有一个，所以需要临界区去控制，临界区是属于对应进程的，是每个进程中访问临界资源的一段代码，临界区还需要进入区和退出区进程检查和恢复。

#### 3.5 死锁

死锁是指多个进程因为竞争资源或者是顺序推进不当而永久阻塞的状态，如果没有外力作用这些进程都无法向前推进。

产生死锁的必要条件：（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能被其他进程强行夺走；（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

 产生的原因：资源不足和不当的推进顺序.

#### 3.6 死锁的策略

死锁的处理策略：鸵鸟策略、预防策略（破坏四个必要条件中的某几个）、避免策略（在动态分配的过程中，防止系统进入不安全状态）、检测与恢复策略（在检测到之后，可以用强制剥夺资源的方式）。

死锁的预防：不剥夺，对于一个已经获得了一些资源的进程，如果申请的资源得不到满足就立即释放。但是这会造成前段时间做的工作全部白费。  请求和保持，一个进程在运行之前一次性申请完所有需要的资源，未满足之前，不投入运行。   环路等待：将所有资源按序编号，进程申请系统资源时按照序号申请，这样不会产生环路。

 死锁的避免：在动态分配的过程中，预知系统是否会进入不安全状态，如果可能产生死锁，则不进行这种分配，银行家算法。

 死锁的检测与解除：检测到死锁发生再采取措施。

