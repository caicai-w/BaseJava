### 六、Linux IO模式

#### 1.你需要具备的基础：

现在操作系统都是采用虚拟存储器，对于32位操作系统而言，它的寻址空间有4G，操作系统的核心是内核，独立于普通的应用程序，内核可以访问受保护的内存空间也有访问硬件的所有权限。为了保证用户进程不直接操作内核，保证内核安全，操作系统将虚拟内存空间划分为两个部分，用户态、内核态。对于Linux来说，将最高的1G字节给内核，低的3G字节给用户进程使用，就是用户空间。

##### 进程切换

任何进程都是在操作系统内核的支持下运行的，所以内核有能力挂起正在cpu上运行的进程，并恢复以前挂起的某个进程，这就是进程的切换。

##### 进程阻塞

正在执行的进程，由于期待的事情没有发生，比如请求系统资源失败，那么这个进程会自动执行阻塞原语，主动的让自己阻塞。

##### 文件描述符fd

fd实际上是一个索引，由内核维护，就是你打开文件或者创建一个文件，操作系统返回给你的一个数字，当程序打开一个现有文件或者创建一个新文件，内核就给进程返回一个fd。

##### 缓存I/O

缓存I/O也叫做标准I/O，大多数文件系统默认I/O操作都是缓存I/O，在Linux的缓存I/O机制中，数据会先copy到操作系统内核的缓冲区中，然后才会从os内核的缓冲区copy到用户程序的空间。

#### 2.IO模式

刚才讲了对于一次IO访问，以（read）为例，数据先被copy到os内核的缓冲区，然后才会从操作系统内核的缓冲区copy到应用程序的地址空间，所以说，当一个read操作发生时，它会经历两个阶段：
1.等待数据准备
2.将数据从内核copy到用户进程中

这个因为这两个阶段，linux系统才产生了下面5种网络模式的方案：
1.阻塞I/O
2.非阻塞I/O
3.I/O多路复用
4.信号驱动I/O
5.异步I/O

#### 3.1阻塞I/O

linux中默认所有socket都是blocking的，当用户进程调用了一个recvfrom这个系统调用，内核就开始IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据一开始没有到达，还需要等待，比如没有收到一个完整的udp数据包（有mtu的限制），这个时候内核要等到足够的数据到来）。这个过程需要等待，也就是数据copy到内核缓冲区是需要时间的，内核要等，而用户进程想要的资源没有，也要等它主动阻塞了。当内核准备好了，它就会把数据从内核拷贝到内存，然后内核返回结果，用户进程才能解除block状态。

所以，block IO是在IO执行的两个阶段都阻塞了。

#### 3.2非阻塞 I/O

当用户发出read操作的时候，如果内核中的数据还没有准备好，就立刻返回error，对于用户进程来说，因为它收到了一个结果，哪怕是error，它也是不用等待的，它就知道数据没有准备好，就会再发一直到等到数据。

所以，nonblocking IO就是用户进程需要不断的主动询问内核准备好了没有。

#### 3.3 I/O多路复用

IO多路复用就是我们说的select，poll，epoll。一个进程可以监视多个fd，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

当用户进程调用select，那么用户进程会被block住，内核会轮询所有调用select的进程他们等待的socket，任何一个socket准备好了，select就会返回，我的理解是：现在有10个用户进程调用select，那么内核就会去轮训10个fd，同时，这10个用户线程都会block住，然后内核中如果有哪个fd准备好了，会返回给对应的进程。

实际中，对于每一个socket，一般都设置成为non-blocking，但是，IO多路复用整个用户的进程其实是一直被block的。只不过进程是被select这个函数block，而不是被socket IO给block。

问题：对于阻塞io，是不是如果我有多个线程要连接socket，那么阻塞io难道要一个一个去处理吗？串行执行？

对于非阻塞io，内核也要阻塞？只是用户进行不需要？但是排在后面的用户进程还是需要阻塞的。

#### 3.4 异步I/O

用户进程发起read操作之后，立刻就可以开始去做其它的事。从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

所以，内核是永远等待的？异步io内核要等待数据准备完成？

#### 3.5 总结

##### 1.blocking和non-blocking的区别

调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。

##### 2.synchronous IO和asynchronous IO的区别

两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。

有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。

而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。

在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。

#### 3.6 select，poll，epoll

一般服务器都用的epoll，比如Nginx，epoll就已经做到了异步IO。他的做法是：事件通知，共享内存。

内核不需要从自己的缓冲空间copy给用户进程了，他们两个有一块共享的内存，对于事件通知，说的是内核不需要去轮询fd中的数据是否有没有准备好，等到数据到达会告诉内核。但是select和poll还需要轮询。

