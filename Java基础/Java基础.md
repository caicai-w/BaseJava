

uncheckException

（问题：java是因为什么设计出低耦合的系统，java的半编译特性，什么是半编译。关于override理解的对不对，自动装箱和拆箱不知道它想说什么，12，13，14，15，16
我一直不理解静态内部类，或者说内部类存在的意义。）

#### 1.面向过程和面向对象的区别

面向过程性能更好，因为它不需要类的加载、实力化这些过程，但没有类的封装、继承、多态的特性，让他的复用性、扩展性不好。

面向对象因为有封装、继承、多态的特性，可以设计出低耦合、易扩展的系统，对于java来说因为有jvm的存在可以让java跨平台，但也因为java的跨平台让java的性能不高，因为它是半编译的语言。

#### 2.Java语言有哪些特点

封装、继承、多态、易扩展、易复用、半编译语言。

#### 3.JVM、JDK、JRE的区别

jre就是java的运行环境，运行已经编译好的java代码，包括JVM、java类库，java命令之类的。jdk是java最全的SDK，包括了jre。
jvm就是java虚拟机了，运行java字节码，就是class文件，就是因为jvm，java才能跨平台。

#### 4.Java和C++的区别

他们都是面向对对象的设计，区别在于java提供了垃圾回收机制，我们不需要去管内存释放的问题，Java不允许用指针，C++可以，java是单继承，c++是多继承。

#### 5.字符型常量和字符串常量之间的差别

就是char 和 String的差别，字符串的实现是final 修饰的char类型数组，所以字符串一旦被创建出来是不可修改的，创建一个字符串的时候会看方法区中的常量池有没有我要创建的这个字符串，如果有的话，就直接指向它。

对于String a="abc"，String b="abc",他们都是指向同一个内存区域，所以a==b为true，对于

new String("abc"),new String("abc"),他们是创建在堆上，但是堆上的数据还是指向方法区存在的常量池，所以两个==比较是不相等的，因为String内部重写了equals，所以equals比较是相等。

#### 6.构造器是否可以被override？

不可以。因为父类构造器根本就不可被继承，和私有属性一样。

#### 7.重写和override的区别

重写是同一个类中的多个方法，属性名相同，但是参数列表不同，返回类型、抛出异常信息等相等也可以不等。

override是父类和子类之间，子类可以覆盖从父类继承过来的方法，比如声明父类指向一个子类，默认就会调用子类的方法，但是子类在同名方法中使用super可以调用到父类的。

#### 8.java面向对象的三大特性

封装：把一个类的方法或者成员变量私有，你只需要提供对外接口。

继承：通过子类继承父类实现，类的扩展和复用。

多态：通过一个父类指向子类，在真正执行的时候，会显示子类中的属性。但是如果你要调用的方法是子类里面独有的，那么编译是通不过的。

#### 9.String、StringBuffer、StringBuilder的区别

String由于内部实现是一个final修饰的char数组，所以是个不可变类，因为不可变所以也是线程安全的。StringBuilder和StringBuffer都是可变的，而StringBuffer内部的方法基本都加了synchronized所以是线程安全的，StringBuilder线程不安全。

#### 10.自动装箱和自动拆箱

#### 11.在java中定义一个不做事的构造方法干什么？

当子类继承父类的时候，子类的构造方法必须调用一个父类的构造方法，如果不显式的调用，就会自动给你调用一个父类无参数构造方法，如果父类没有就会出错。

#### 12.接口和抽象类的区别

1.8之前接口是不能有任何实现的，是完全抽象的存在，而抽象类可以有实现了的方法。当抽象类被实现，和子类之间是继承的关系，而接口的设计，更多是让类具有某种功能。接口方法默认都是public修饰，变量也只能是static、final修饰。

类可以实现多个接口，但只能继承一个类。

#### 13.成员变量和局部变量的区别

成员变量是在类加载的时候就分配了存储空间，(这个说的不准确，应该是类变量在类加载的时候分配了存储空间)分配在了方法区上并给他们赋了零值，除非是final修饰的会直接赋值。

局部变量的话，是分配在每个方法的栈上，不会自动赋值。而且，局部变量是不需要被public这些修饰的。

#### 14.创建一个对象用什么运算符，对象实体和对象引用有什么不同？

new，对象实体是分配在堆上的，而对象引用是是在栈里面存储着堆上要引用对象的地址。

#### 16.一个类的构造方法有什么作用，如果没有构造方法，类可以正常执行吗？

主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

#### 17.构造方法有哪些特性？

可以重载，名字和类名相同，没有返回值，生成类的对象时自动执行，不需要调用。

#### 18.静态方法是实例方法与什么不同？

静态方法是属于类的，会保存到方法区上，实例方法是属于某个对象的。（难道不是static修饰的类方法区上就不保存？）

#### 20.== 和 equals

==比较的是两个对象的地址，equals如果你重写了，就是调用你重写的方法，如果没有还是比较地址。对于String来说，因为String重写了hashcode方法，所以比较的不是地址，而且String如果没有用new的话，是从常量池拿的。

对于其他Integer这些包装类型来说，如果是-128-127之间的数字，也是直接拿缓存，所以Inetger i=1，和Integer j=1，==两个是相等的，对于Integer i = new Integer(1)的话，==肯定是不等，因为是分配到堆上的不同对象。

如果你重写了equals，就一定要重写hashCode，因为原本的hashCode默认是根据堆上对象的地址生成一个hashcode出来，java原本的设计就是equals比较对象地址，而hashCode()又是根据地址得到的，所以两个要想到就都要相等，你只改写了一个，违背了它的设计。

#### 21.java中为什么只有值传递？

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。

- 一个方法可以改变一个对象参数的状态。

- 一个方法不能让对象参数引用一个新的对象。

#### 22.请简述进程、线程、协程的区别

线程是cpu调度的基本单位，它可以和多个从属于一个线程的进行共享内存空间。进程是资源分配的最小单位，线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。
协程，是一种用户态的轻量级线程的存在，协程有自己的上下文，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

#### 23.线程有哪些状态

java线程在程序运行只有6中状态

new，线程被创建，还没有调用start

runnable，正在运行和就绪。

waiting，等待，

blocked，阻塞，比如没拿到锁。

time_waiting，超时等待，它的等待是有时间限制的。

TERMINATED，终止状态，表示当前线程已经执行完毕。



#### 24.关于final关键字的总结

final可以修饰类、方法、变量。

修饰的类不可以被继承，类中方法都会默认被final修饰。修饰方法，一种是为了方法不被子类override，还有是其实所有private都会隐式的制定为final。修饰变量，则变量不可以被修改，如果是基础数据类型变量，则数值不可以修改，如果是引用类型，则引用不能修改。

#### 25.异常

异常顶层父类：throwable，下面分为Error和Exception，一般Error是虚拟机出现错误，比如栈的空间不够了这样，这些错误是不可查的，因为他们在应用程序的控制和处理能力之外。

Exception是程序可以处理的异常，

可以分为checkedException和uncheckedException。

#### 25(2).finally什么情况下不会执行

正常情况下，finally总会被执行，当在try块或者catch块中遇到return语句时，finally语句将在return之前被执行。在finally语句的第一行发生了异常，CPU关掉了，或者程序down了。

#### 26.Java IO流

Java io涉及到40多个类，都是从这四个派生出来的：
InputStream/Reader，所有输入流的基类，字节/字符
OutPutStream/Writer，所有输出流的基类，字节/字符

BIO、NIO、AIO有什么区别：

BIO:同步阻塞IO模型，数据的读取写入必须阻塞在一个线程内等待其完成，在活动链接数不高的情况下这个还行，每一个链接专注自己的I/O。

NIO：同步非阻塞的I/O模型，它是面向缓冲，基于通道的I/O操作方法，NIO提供了与BIO Socket、ServerSocket相对应的SocketChannel和ServerSocketChannel。

AIO：异步非阻塞IO模型，异步IO是基于事件和回调机制实现的，就是后台处理完成之后会给通知相应的线程。

#### 27.常见关键字总结

static关键字：
修饰成员变量和成员方法，表示修饰的东西属于这个类，所有对象共有，成员变量分配在方法区上。
静态代码块：如果一个类有静态代码块，那么这个类内部的执行过程：静态代码块 -> 非静态代码块 ->构造方法。不管创建多少个对象，静态代码块只执行一次。
静态代码块格式:

```
static{
语句
}
```

静态代码块可以有多个，位置可以随便放，它不再任何的方法体内，JVM加载类时会执行这些静态的代码块，如果有多个静态代码块，JVM会按照他们在类中出现的先后顺序依次执行它们。

```java
public class Demo
{
    static
    {
         i=3;
         System.out.println(i);//报错，静态代码块对于定义在它后面的静态变量可以赋值但不能访问。
    }
    private static int i;
}
```

静态内部类
静态内部类实现单例模式：

```java
public class Singleton{
 private Singleton(){
 }
 //声明为private表明静态内部类只能在该Singleton类中被访问
 private static class SingletonHolder{
  private static final Singleton INSTANCE = new Singleton();
 }
 public static Singleton getUniqueInstance(){
   return SingletonHolder.INSTANCE;
 }
}
```

当Singleton类加载时，静态内部类SingletonHolder没有被加载进内存，只有当调用getUniqueInstance()的时候会触发，才会被加载，并且JVM能确保INSTANCE只被实力化一次。
这种方式不仅具有延迟初始化的好处，而且由JVM提供了对线程安全的支持。
静态导包

补充：

##### static{}静态代码块和{}非静态代码块的区别：

相同点：都是在JVM加载类的时候，并且在构造方法执行之前，在类中都可以定义多个。
不同点：静态代码块在非静态之前执行，静态代码块只是在第一次new的时候窒息性一次，而非静态代码块在每次new的时候都执行一次。


super关键字主要是子类访问父类的变量和方法。
在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
this、super不能用在static方法中，因为 this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。

#### 28.值传递

```java
public void mainTest(){
    String str = "abc";
    trans(str);
    System.out.println(str);
}
public void trans(String str){
    str = "xxx";
}
```
结果还是abc，因为传递给trans的时候，是传递了一个字符串的引用，是copy了一个引用过去，copy过去的指向了常量池的另一个，原来的还是该指哪指哪里。
