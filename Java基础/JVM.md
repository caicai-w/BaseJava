## JVM的作用

为了能让java跨平台、跨不同的操作系统，有了字节码这个中间码，jvm就是去运行这个中间码的东西，如果是热点代码，会通过JIT动态的编译为机器码提高执行效率。JIT就是如果有个方法运行的特别频繁，这些代码就是热点代码，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为*即时编译器*JIT，JIT并不是JVM必不可少的一部分，所以并不是所有的Java虚拟机都采用解释器与编译器并存的架构，Java程序一般都是通过解释器进行解释执行的。

## 一、Java内存区域

Java虚拟机在运行程序可以分为下面几个部分：

### 1.程序计数器
记录当前线程执行字节码的行号，每个线程私有，不会有OutofMemoryError的情况。

### 2.java虚拟机栈
它的生命周期和线程相同，虚拟机栈描述的是Java方法执行的内存模型，每个方法执行会建立一个栈帧，存储局部变量表、操作数栈等，局部变量表存的是编译阶段知道的各种基本类型和对象的引用等。如果线程请求的栈深度大于虚拟机允许的深度，会抛出StackOverFlow异常，如果虚拟机允许动态扩展并且在扩展时申请不到足够内存，也会抛出OutofMemoryError。下面是栈帧中的结构
（1）局部变量表：放方法传进来的参数和本地变量表，局部变量必须显式初始化，

### 3.本地方法栈
和java虚拟机栈差不多，只不过是调用的本地方法服务。

### 4.Java堆
所有对象的实例都在堆上分配，但是随着逃逸分析技术也会有一些变化，也不是所有对象都在堆上了，堆是GC重灾区。堆不要求在物理上连续，只要逻辑连续就行。当堆中没有足够的内存分配也无法扩展时，会OutofMemoryError。当对象的年龄超过默认的阈值15就会被移到老年代，分配对象的时候，如果新生代放不下，YGC之后也放不下就放到老年代去，或者移动的时候survivor放不下，也放到老年代。

### 5.方法区
也是线程共享的，用来存储虚拟机加载的类信息、常量、静态变量、还有JIT编译的热点代码。在jdk8开始，这个就叫元空间了，字符串常量移到堆内存，其他还在元空间。

#### 5.1 运行时常量池
是方法区的一部分，Class文件除了有类的版本、方法、字段、接口等，还有一项就是常量池，常量池用于编译时期生成的字面量和符号引用。什么是字面量呢？就比如String s=“abc”，那么这个abc就会放到这个方法区里面，符号引用就是说，比如一个Person类，它引用了一个Apple类，那在编译Person类的时候实际上是不知道Apple类的内存地址，所以就放个符号引用在那，类装载器在装载的时候，会去给你装成实际的地址。常量并不一定只有在编译的时候才会产生，比如String 的intern()方法也是在运行的时候会把产生的字符串放到常量池，当运行时常量超出方法区内存限制，也会抛出OutofMemoryError。

### 6.直接内存
它不是jvm运行时数据区的一部分，但被频繁使用在这一块说了。nio基于通道与缓冲区的io方式。可以直接操作内存。

### 7.对象创建

虚拟机遇到new指令首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否被加载过、解析、初始化过。如果没有，就要先执行类加载。
加载完后，接下来为虚拟机为新生对象分配内存，对象所需的大小在类加载完之后可以完全确定，分配内存时，如果内存是规整的，那就把空闲指针挪动一段和对象大小相等的距离，这叫指针碰撞，如果不是规整的，使用的和空闲的区域交错，就从空闲列表找是否有合适的。Java堆是否规整由采用的垃圾收集器是否带有压缩整理功能决定，在使用Serial、ParNew、等带有compact的收集器时用指针碰撞，而CMS这种基于mark-sweep算法收集器采用空闲列表。
要知道内存分配并发下可能会出现问题，解决方案一种是堆内存分配进行同步处理（采用CAS配上失败重试的方式保证更新操作的原子性），一种是把内存分配的动作按照线程划分在不同的空间之中进行，就是先给每个分配线程都分配一块空间，叫做TLAB，本地线程分配缓冲。
内存分配完成后，虚拟机需要把分配到的内存空间初始化为零值，这一步保证了对象的实例字段在java代码中可以不赋初始值直接使用。
接下来，对对象进行设置例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的hash码，对象GC分代年龄等。这些信息放在对象头里面。
在上面工作做完之后，对象创建才刚刚开始，init方法还没有执行，接下来按照程序员的意愿初始化，这样一个真正可用的对象才算是完全产生出来。

### 8.对象的内存布局

对象在内存中可以分为3块区域：对象头、实例数据、和对齐填充。
对象头包括两部分信息：一部分是自身的运行时数据、比如hash码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等，官方称它为“Mark Word”。

另一部分是类型指针，指向对象的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有虚拟机实现都必须在对象中保留类型指针，也就是，查找元数据信息不一定要经过对象。另外，如果是数据还要记录一下数据长度，因为虚拟机可以用普通java对象的元数据确定内存大小，但数据不行。
实例数据就是无论从父类记录下来还是子类定义的，都需要记录下来。HotSpot虚拟机默认会把宽度相同的一起分配。最后，对齐就是占位符，要求对象必须是8字节的整数倍。

### 9.对象的访问定位
我们通过栈中的指针才操作堆上的具体对象。实现方式有两种，一种是直接指向对象地址，一种是句柄。

### 10.如何判断一个类是否是无用的类？
方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？
类需要同时满足下面 3 个条件才能算是 “无用的类” ：
该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
加载该类的 ClassLoader 已经被回收。
该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

### 11.如何判断一个常量是废弃常量？
运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？
假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。
JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

### 12.对象如何进入老年代的
一个普通的Java对象，出生在Eden区，每经过一次Miner GC 只要对象存活下来，他就会在两个Survivor区来回移动，年龄也+1岁，等他到了一定的岁数，就去老年代那边。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。
还有就是如果对象需要的内存空间非常大，会直接分配到老年代。

## 二、垃圾收集

上面说了java运行时的各个区域，对于程序计数器、虚拟机栈、本地方法栈他们随着方法或者线程的结束而结束，栈帧分配多少内存基本上在类结构确定下来就是已知的，这个区的内存回收都有确定性。
但是java堆就不一样了，我们只有在程序运行时才知道会创建哪些对象，这部分内存分配都是动态的。

### 1.对象是否可被回收

#### 1.引用计数法
就是每个对象有一个引用计数器，有人引用计数器就+1，没人引用就说明可以被回收了，但是循环引用会让两个没用的对象谁也不被回收。

#### 2.可达性分析
以GC Root对象为起点，向下搜索，走过的路径被称为引用链，如果一个对象没有被链上，就说明可以被回收。
但其实即使在可达性分析中不可达的对象也不是非死不可，要宣告一个对象真正死亡，至少要经过两次 标记过程，如果对象不可达，先被标记一次，然后在这些标记对象中看他们有没有覆盖finalize()，需不需要执行，如果不要，直接二次标记。如果需要，那么对象可能还有救。这个方法一般是用来做一些资源清理工作的。
**GC Root**可以是：虚拟机栈（栈帧中的本地变量表）引用的对象。
                             方法区中类静态属性引用的对象。
                             方法区中常量引用的对象。
                             Native方法中引用的对象。

### 2.四种引用
引用还被分为：**强引用、软引用、弱引用、虚引用**。
这些区分是为了当内存空间还足够的时候，则可以保存在内存中，如果内存空间在垃圾收集之后还是很紧张，那就抛弃了。 System.gc()只是通知，JVM不是你通知它回收它就回收了，只有内存不够了才回收。
强引用就是程序代码中普遍存在的，new，只要强引用还在，永远不会被收集，JVM宁愿抛出OOM异常，也不会去收集它解决内存不足的问题。所以在不使用一个对象的时候，最好设成null。

软引用就是还有点用但也不是必须有的对象，在系统要内存溢出之前会回收他们，如果回收完之后还溢出，就抛异常。软引用有什么作用呢？比如在浏览网页时，我们可以把浏览过的页面设成软引用，如果内存充足，软引用就会被保存，点击浏览器后退按钮，就不用重新加载页面。而且最近浏览过的越有可能被保存，就是引用队列的作用。

弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引用只能活到下一次垃圾回收之前。

虚引用，完全无法通过虚引用获取到一个对象，它的唯一目的就是这个对象被收集器回收到时收到一个系统通知。
虚引用主要用来跟踪对象被垃圾回收的活动。

虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。

### 3.对象回收的方法

#### 3.1.标记清除
首先标记所有要回收的对象，然后统一回收，但这样会产生很多内存碎片。

#### 3.2 复制算法
最开始是把内存分两块，一次只用一块，当一块用完了，就把存活的对象复制到另一块上去，直接整个半块清理掉。

#### 3.3 标记-整理
因为老年代的对象不像新生代存活率那么低，所以针对老年代都是在标记不可达之后，让所有存活的对象移动到一端，然后清理掉边界外的。

#### 3.4 分代回收
现在虚拟机都采用分代回收来回收新生代，堆可以分为新生代和老年代，新生代包括Eden和两个Survior，新生代用复制算法，老年代用标记整理，复制算法将Eden区和from survivor区还存活的对象一并复制到to survivor区。因为新生代存活的很少，每次复制的也不多，如果复制的多一些不够了，可以去来年代分配担保多申请点。

## 三、垃圾收集器

### 3.1.Serial收集器
Serial(串行)收集器单线程收集器，是stop-the-world，也就是必须暂停其他所有线程直到它收集结束。Serial在新生代采用复制，在老年代（Serial-Old）采用标记-整理。它是单线程没有线程交互的开销，所以单线程下的效率也还行，适合Client用。

### 3.2.ParNew收集器
其实它是Serial收集器的多线程版本，除了多线程外其余都一样，新生代采用复制，老年代采用标记-整理。它是许多运行在server模式下的虚拟机的首要选择。
但是在单CPU环境下ParNew的表现绝对不会比Serial好，甚至因为线程切换的开销比Serial要差。除了Serial之外，只有它能与CMS（用在老年代）收集器配合工作。
在这里并发是：多个垃圾回收线程一起工作，但用户线程处在等待状态。

### 3.3 Paraller Scavenge收集器
也是使用复制算法的多线程收集器，它看上去和ParNew差不多，差别在侧重点不同。Paraller Scavenge关注点是吞吐量，CMS关注用户线程的停顿时间（用户体验），所谓吞吐量就是cpu中用于运行用户代码的时间和总耗时占比。
这两种的差别在于：关注吞吐量适合多计算任务的场景，停顿时间适合多交互场景。
Paraller Scavenge有两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间-XX:MaxGCPauseMills参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。XX:MaxGCPauseMills是个大于0的毫秒数，你设置的越小是以牺牲吞吐量和新生代空间换来的，可能垃圾回收的次数更多。
它还有个参数-XX:UseAdaptiveSizePolicy,这是一个开关参数，打开这个开关之后，就不需要手动设置新生代的大小，Eden和Survivor区域的比例，晋升老年代对象大小等细节参数，开启自适应调节策略，jvm会替你做。
它无法和CMS配合。
新生代采用复制算法，来年代用标记整理。

### 3.4.Serial Old收集器
Serial收集器的老年代版本，它同样是一个单线程收集器，有两大用途：一个是在jdk1.5之前和Paraller Scavenge搭配使用，一种是作为CMS的后备方案。

### 3.5.Parallel Old收集器
Paraller Scavenge的老年代版本，使用多线程和标记-整理，在注重吞吐量和cpu资源的场合，都可以优先考虑Paraller Scavenge收集器和Parallel Old收集器。
但是这个收集器是在1.6才有的，在它出现之前，Paraller Scavenge是处于比较尴尬的状态，因为如果选择了Paraller Scavenge回收新生代，由于CMS无法和Paraller Scavenge配合，老年代只能用Serial Old。

### 3.6 CMS收集器
CMS是非常注重用户体验，以获取最短回收停顿时间为目标的收集器。即便最短停顿时间是他它的目标，但这个最短也是相对于老年代来说的。
第一次实现了让垃圾收集线程与用户线程同时工作。
CMS是一种“标记-清除”算法实现的，它的过程分为以下4个步骤：
1.初始标记：stw，暂停所有其他线程，并记录下直接与root相连的对象，速度很快。
2.并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象，但在这个阶段，因为用户线程可能又有了新的引用。
3.重新标记：stw，并发期间导致标记发生变动的那一部分对标记记录，在这个阶段的停顿时间一般会比初始标记阶段的时间稍长，比并发标记时间短。
4.并发清除：开启用户线程，同时GC线程开始为标记的区域做清扫。
虽然它并发收集、低停顿，但是有三个明显的缺点：
1.对cpu资源要求高，cms在回收时默认设置线程数量是(cpu数量+3)/4，其实这样基本就拿掉了你25%的cpu资源，如果服务器本身负荷就不低了，就会让整个吞吐量都降低，把用户线程拖慢。
2.无法处理浮动垃圾，因为在并发清除的时候，用户线程还是可以创建新的对象出来，这要求你不能等到整个老年代都快满了才去收集，可以设置参数CMSInitiatingOccupancyFraction来修改old还剩多少的触发full gc，但如果预留的空间真的不够这一次gc了，虚拟机会启动后备预案，临时启用Serial Old来对来年代进行收集。
3.使用的“标记-清除”算法会导致收集结束时有大量空间碎片产生，但CMS默认每次进行Full gc都带着碎片整理，内存整理的过程是无法并发的。

### 3.7 G1收集器
相比较于CMS，G1具备压缩功能避免碎片，让停顿时间更可控制，G1将java堆空间分隔成了若干大小相同的区域，既region，包括Eden、Servivor、Old、Humongous四个区域，Humongous是特殊的Old类型，专门放大对象。优先回收垃圾最多的区域，G1的优势在于可预测的停顿时间。是面向服务器的垃圾收集器，主要分四个步骤：
1.初始标记
2.并发标记
3.最终标记
4.筛选回收
G1收集器在后台维护了一个优先列表，每次允许的收集时间、优先选择回收价值最大的region。
G1的特点：
分代收集：虽然G1不需要其他收集器配合，能独立管理整个GC堆，但还是保留了分代的概念。
空间整合：与CMS的“标记-清理”算法不同，G1从整理来看是基于“标记整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。

## 四.JVM参数

JVM参数类型：标配参数（version、help）、X参数、XX参数（重要）

##### 1.XX参数

```
-XX:+某个属性-某个属性//开启/关闭某个属性
-XX:key=value
```

```
jps -l
jinfo -flag PrintGCDetails 号码 看看这个线程开启没 
-XX:+PrintGCDetails
jinfo -flags 号码//所有配置都出来，有初始、你加的
-Xms 等价于-XX:InitialHeapSize 初始化堆内存
-Xmx 等价于-XX：MaxHeapSize 最大堆内存
```

jvm初始化最大堆是根据你的内存，一般是1/4

查看JVM初始参数
java -XX：PrintFlagsInitial 
查看修改后的值
java -XX：PrintFlagsInitial 
（= := jvm修改过或人为修改过）
1.8之后把最初的永久代取消，由元空间取代，元空间和永久代区别在于：永久代使用JVM的堆内存，但是java8以后元空间不在虚拟机而是在物理内存。默认情况下，元空间大小只受本地内存限制。类的元数据放在native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermize控制。
元空间本质和永久代类似，都是对JVM规范中方法区的实现，区别是：元空间不在虚拟机而是在物理内存。默认情况下，元空间大小只受本地内存限制。

## 五、类文件结构

任何一个类的二进制字节码开头都是cafe babe，是一个魔法数，标志这是一个java 文件。

### 1字节码主要指令

1.加载/存储指令

在某个栈帧中，通过指令操作数据在虚拟机栈的局部变量表与操作栈之间来回传输，常见指令如下：（1）将局部变量加载到操作栈中，如ILOAD（将int类型的局部变量压入栈）和ALOAD（将引用类型的局部变量压入栈）。（2）从操作栈顶存储到局部变量表，如ISTORE，ASTORE等。

2.同步指令

JVM'使用方法结构中的ACC_SYNCHRONIZED同步标志方法，指令集中有monitorenter和monitorexit支持synchronized语义。

### 2.关于字节码，dubbo过满

我们写好的.java是源代码文件，需要编译成字节码甚至是机器码文件，那么静态编译器如何把源码转化成字节码呢？

java源文件先经过词法分析，词法分析是通过空格分隔出单词、操作符、控制符等，形成一个token流，传递给语法解析器，在语法解析时，把词法解析得到的token按照Java语法规范组装成一棵语法树，接下来进行语义分析，语义分析要看关键字的使用是否合理，类型是否匹配等，语义分析完成之后就可以生成字节码。

字节码必须通过类加载过程加载到JVM环境之后，才能执行。加载过程后面会说。执行有三种模式：第一，解释执行，第二，JIT编译执行，第三，JIT编译与解释混合执行（主流JVM默认执行模式）。混合执行模式的优势在于解释器在启动时先解释执行，省去编译时间，随着时间推进，jvm通过热点代码统计分析，识别高频方法调用、循环体、公共模块等，基于JIT动态编译把热点代码转换成机器码，直接交给cpu执行。

这个地方书上讲了为什么服务上线的时候要分批发布，那我们每次上线dubbo线程池过满会不会是这个原因，机器在热机状态下可以承受的负载要大于冷机状态，如果以机器热机的状态进行切流，可能使处于冷机状态的服务器因无法承受负载而假死，所以每次发布的时候都要分批发布，因为机器刚启动的时候jvm都是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，可能跟不上之前的负载，说明了JIT编译的存在。但是线上也无法验证啊。

## 六、类加载过程

任何程序都需要加载到内存才可以和cpu交流，字节码同样要先加载到内存才可以进行实例化，类加载器的使命就是提前加载字节码到内存，采用双亲委派模型。jvm加载class文件可以分为三个步骤：

### 1.加载

加载阶段读取类的二进制字节流，转换成方法区能运行的数据结构，初步校验cafe babe魔法数，常量池，是否有父类等，然后创建对应的java.lang.Class实例。

加载阶段和连接阶段是交叉进行的，可能加载还没有结束，连接阶段就开始了。

### 2.连接（验证->准备->解析）

验证：验证是更详细的校验，比如final是否符合规范、类型是否正确等等。
准备：为类变量分配内存，设置类变量初始值的，这些都是在方法区的内存分配，分配仅仅是类变量（static），分配的零值。比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。
解析：把jvm常量池内的符号引用替换成直接引用。
符号引用是用一组符号来描述目标，可以是任何字面量，直接引用就是直接只想目标的指针，在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。
综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 3.初始化

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码，初始化阶段是执行类构造器方法的过程。初始化的顺序：静态变量->静态代码块->构造函数->自定义构造函数
对于构造方法的调用，虚拟机会自己确保其在多线程环境中的安全性。
对于初始化阶段，虚拟机严格规范了有且只有5中情况下，必须对类进行初始化：
1.当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
2.使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。
3.初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4.当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5.当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。

### 4.类加载器

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：

1.BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。
2.ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
3.系统（System）类加载器：AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

#### 4.1 加载类使用的都是双亲委派

双亲委派机制描述：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

思考🤔：
1.Java虚拟机的第一个类加载器是Bootstrap，这个加载器很特殊，它不是Java类，因此它不需要被别人加载，它嵌套在Java虚拟机内核里面，也就是JVM启动的时候Bootstrap就已经启动，它是用C++写的二进制代码（不是字节码），它可以去加载别的类。
这也是我们在测试时为什么发现System.class.getClassLoader()结果为null的原因，这并不表示System这个类没有类加载器，而是它的加载器比较特殊，是BootstrapClassLoader，由于它不是Java类，因此获得它的引用肯定返回null。

#### 4.2 委托机制具体含义：

当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢？

首先当前线程的类加载器去加载线程中的第一个类（假设为类A）。
注：当前线程的类加载器可以通过Thread类的getContextClassLoader()获得，也可以通过setContextClassLoader()自己设置类加载器。
如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器去加载类B。
-还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。

#### 4.3 使用原因，委托机制的意义：

防止内存中出现多份同样的字节码，比如两个类A和类B都要加载System类：
如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。
如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。

#### 4.4 如何打破双亲委派

## 七、Java内存模型和线程

### 1.与硬件的类比

先不说java，就说cpu，我们为了能更加充分的利用cpu资源，有了并发的概念，在一段时间内让cpu执行多个程序，这里的问题就是，绝大多数任务都不是仅仅通过运算就可以完成的，cpu总要和内存交互，进行数据的读取、运算等等，这个IO是很难消除的，虽然现代操作系统为了减少cpu运算速度的I/O速度之间的鸿沟，都引入了高速缓存，运算使用到的数据复制到高速缓存中，让运算能快速进行，完了之后再写到内存去。但这样就有了缓存一致性的问题，在多cpu的处理系统中，每个cpu都有自己的高速缓存，他们又共享同一内存，那么，如果他们操作了同一块内存，最后把数据刷回内存的时候，以谁的为准呢？所以在各个处理器访问缓存的时候需要遵循一些协议，比如MSI、MESI、MOSI等等。

所以当后面提到内存模型的时候，可以理解为特定的操作协议下，对特定的内存或者高速缓存进行访问/读写的过程。Java虚拟机也有自己的内存模型。

除了增加高速缓存之外，为了能让cpu充分利用，cpu可能会对你输入的代码进行乱序执行优化，它会保证该结果与顺序执行的结果是一样的。与处理器的乱序执行类似，jvm也有重排序，就是为了让cpu执行的更快。

### 2.Java内存模型

JVM定义自己的java内存模型，目的就在于，屏蔽掉各种硬件和操作系统的内存访问差异，让java程序不管在什么平台都能提供一样的访存效果。

java内存模型看起来是这样的：每个线程操作自己的工作内存，但是工作内存的数据是从主内存中copy过来的，处理完之后也要刷到主内存。

### 3.主内存和工作内存

java内存模型就是为了定义程序中各个变量的访问规则，也就是虚拟机中将变量存储到内存和从内存取出变量这样的底层细节。这里说的变量不包括局部变量与方法参数，因为这些是线程私有的，不会被共享。所以这里说的变量就是比如实例字段、静态字段和构成数组对象的元素，Java内存模型规定了所有的变量都存储在主内存，类比计算机主存。你可以理解为java堆上的对象实例的数据部分，而工作内存对应java虚拟机栈的部分区域。

### 4.主存见的交互操作

关于主内存和工作内存如何交互，也就是一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存，java内存模型中定义了8种操作来完成，jvm实现时必须保证下面的每一种操作都是原子性的，对于double和long来说有例外，后面再说。

lock:把主内存的一个变量标志为独占状态。

unlock：把主内存锁定的变量释放出来。

read：从主内存读取数据。load：把read到的数据放到工作内存去。

store：把工作内存的数据传到主存去。write：作用与主内存的操作，把store操作的数据写到主内存中去。

use：把工作内存中的一个变量的值传到执行引擎。

assign：把执行引擎收到的值赋给工作内存中的变量。

所以如果你要是想把数据刷到内存、或者从内存读出来，jvm要求必须顺序的执行store和write，read和load，但它只要求顺序，并没有要求连续，也就是这其中是可以有其他操作插进来的。

### 5.volatile关键字

它可以说是jvm提供的最轻量级的同步机制，volatile修饰的变量保证了，每次线程在获取这个变量的值的时候都去主存刷一次拿到最新的，对于执行引擎来说，它永远看不到不一致的情况，但是因为java里面的运算并不是原子性的，所以volatile变量在并发环境下不是安全的。

你比如经常说的i++这个操作，这一个i++编译之后是有4条字节码指令：

getstatic //把i的值取到操作栈的栈顶，在这一步操作它保证了从主存拿到最新的数据，

iconst_i

iadd.      //在走到这两步的时候，实际上i的值可能已经被加大了，栈顶的元素只能是当时的最新，在执行到这里的时候已经不是新的了。

putstatic

第二个特点就是禁止指令重排序优化，对于没有volatile修饰的普通变量，它不能保证变量赋值操作的顺序和程序代码的一致，但是结果是一样的，其实这个设计和cpu很像，很像也有乱序执行的优化，jvm的编译器也有这样的优化，volatile修饰的变量在赋值的时候多了内存屏障，重排序的时候内存屏障后面的指令不能跑到前面去。

虽然volatile是轻量级的同步机制，但是因为jvm对synchronized的优化，不能说它就比syn快多少。但是如果和自己比较，volatile修饰的变量读操作的性能损耗和普通变量差不多，但是写操作会慢一点，因为它需要插入一些指令保证不会被乱序执行。

### 6.Java内存的线程模型

java内存模型都是围绕着在并发过程中如何处理原子性、可见性、有序性这3个特征来建立的。

原子性说的就是主内存和工作内存之间的交互，那8个指令，你可以理解基本数据类型的访问读写都是具备原子性的。

可见性就是前面说的volatile，它通过每次在使用之前从主内存拿最新的值，每次使用完成后刷回主存来保证。除了volatile，syn和final也可以保证可见性。

有序性，在各个线程内看起来都是有序执行的，即便他给你乱序优化了，但其实结果是一致的，但是呢，在一个线程中去看另一个线程就是无序的，除了volatile，syn也可以做到。

### 7.jdk1.6对锁技术的优化

自适应自旋锁：如果jvm认为这个共享数据的锁只会被持有很短的一段时间，没必要把当前请求不到资源的线程给挂起来，就执行自旋。执行自旋的次数取决于上一次线程在同一个锁的等待时间，如果上次成功了，可能在这次允许自旋的次数就更长一点，如果上次没有，那可能这次就不会自旋。

锁消除：比如你有一个这样的方法

```java
public String constractString(String s1,String s2,String s3){
   return s1+s2+s3;
}
```

在jdk1.5之后这个操作会转换为StringBuffer的连续append操作，StringBuffer是会天然加锁，但是实际上，这个方法的执行不涉及对共享变量的操作，没必要加锁，所以在编译的时候，会自动把这个地方的加锁给消除掉。

锁粗化：如果连续对同一个对象反复加锁，jvm探测到就会把加锁范围夸大到整个加锁序列的外部，只需要加一次就好了。

### 8.JVM对Synchronized的优化

优化之后的synchronized锁分为下面几个状态：1.无锁，2.偏向锁，3.轻量级锁，4.重量级锁。不同的锁状态, 对象头中的MarkWord中存储的内容也不一样。

![屏幕快照 2019-09-17 下午6.22.46](/Users/didi/Desktop/屏幕快照 2019-09-17 下午6.22.46.png)

#### 1.偏向锁

偏向锁是对于一个线程而言的,一个线程获取到锁之后后面可以再直接获取，就是可重入的设计。假如有两个线程来竞争该锁话, 那么偏向锁就失效了, 进而升级成轻量级锁了。
偏向锁怎么加锁？：它锁的一定是某个数据，共享数据，然后这个数据是属于某一个对象的，会把第一个获取到这个锁对象的Mark Word中的标志为设置为01，并使用CAS记录线程id。以后同一个线程再来请求的时候，就直接获取。
偏向锁怎么撤销？：当其他线程尝试竞争偏向锁时, 偏向锁就结束了，首先会暂停持有偏向锁的线程, 然后检查持有偏向锁的线程是否存活, 如果线程不处于活动状态, 则将锁对象的对象头设置为无锁状态; 如果线程仍然活着, 那就升级为轻量级锁。

#### 2.轻量级锁

在代码进入同步语句的时候，如果此同步对象没有被锁定，也就是锁定标志位位01，也不存在偏向锁的时候，jvm会在jvm虚拟机栈的栈帧中建立一个名为锁记录的空间（Lock Record），用于存储锁对象目前的Mark Word拷贝（也就是有hashCode的那些），然后jvm会通过CAS更新Mark Word头部把锁指针指向复制的拷贝，再把所得标志位改成00，表示当前处于轻量级状态。如果加锁失败，发现这个线程已经被其他线程抢占了，就进入了一个重量级状态。

线程的几种创建方式，这个像几年前一样，我还是不明白！！！！

## 八、JVM的主要组成

类加载器，运行时数据区，执行引擎，本地库接口
类加载器会把java代码 v转成字节码，运行时数据库会把字节码加载到内存当中，字节码需要执行引擎把字节码翻译成底层操作系统可以看的懂的系统指令，再交给CPU执行，这个过程中需要调用本地库接口来实现程序的功能。



