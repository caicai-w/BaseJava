#### 1.三个线程循环输出ABC

写法1:Semaphore实现

```java
package ThreadQ;

import java.util.concurrent.Semaphore;
public class Foo {
    //用信号量实现
    private static Semaphore A = new Semaphore(1);
    private static Semaphore B = new Semaphore(0);
    private static Semaphore C = new Semaphore(0);
    static Runnable r1 = () ->{
        while (true){
            try {
                A.acquire();
                System.out.println("A");
                B.release();
            }catch (InterruptedException e){
                e.printStackTrace();
            }

        }
    };

    static Runnable r2 =()->{
        while (true){
            try {
                B.acquire();
                System.out.println("B");
                C.release();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    };

    static Runnable r3 =()->{
        while (true){
            try {
                C.acquire();
                System.out.println("C");
                A.release();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    };
    public static void main(String[] args) throws InterruptedException{
        /**
         * 没有想明白的地方：
         * 1。线程start之后，能够运行多久
         *    一个线程start之后，只能运行一次，由于多线程环境下，cpu执行的时候会随时切换，也就是你的r1 r2 r3开启之后
         *    不一定是谁先执行，谁后执行，也不一定中间在执行的过程中，cpu就切到另一个线程执行了。
         *    
         * 2。为什么能够循环不停的输出ABC
         *    因为每个线程做了死循环，当r1在做死循环的时候，因为acquire不到，就挂起来了，那么就会切换到r2 或者 r3执行，明显只有r2可以执行
         *    就这样，虽然写了死循环，不要觉得cpu就卡在那里了，线程是永远在交替的不停的执行的。
         */
        new Thread(r1).start();
        new Thread(r2).start();
        new Thread(r3).start();

    }
}

```

