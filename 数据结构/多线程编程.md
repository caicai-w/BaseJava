#### 1.三个线程循环输出ABC

写法1:Semaphore实现

```java
package ThreadQ;

import java.util.concurrent.Semaphore;
public class Foo {
    //用信号量实现
    private static Semaphore A = new Semaphore(1);
    private static Semaphore B = new Semaphore(0);
    private static Semaphore C = new Semaphore(0);
    static Runnable r1 = () ->{
        while (true){
            try {
                A.acquire();
                System.out.println("A");
                B.release();
            }catch (InterruptedException e){
                e.printStackTrace();
            }

        }
    };

    static Runnable r2 =()->{
        while (true){
            try {
                B.acquire();
                System.out.println("B");
                C.release();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    };

    static Runnable r3 =()->{
        while (true){
            try {
                C.acquire();
                System.out.println("C");
                A.release();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    };
    public static void main(String[] args) throws InterruptedException{
        /**
         * 没有想明白的地方：
         * 1。线程start之后，能够运行多久
         *    一个线程start之后，只能运行一次，由于多线程环境下，cpu执行的时候会随时切换，也就是你的r1 r2 r3开启之后
         *    不一定是谁先执行，谁后执行，也不一定中间在执行的过程中，cpu就切到另一个线程执行了。
         *    
         * 2。为什么能够循环不停的输出ABC
         *    因为每个线程做了死循环，当r1在做死循环的时候，因为acquire不到，就挂起来了，那么就会切换到r2 或者 r3执行，明显只有r2可以执行
         *    就这样，虽然写了死循环，不要觉得cpu就卡在那里了，线程是永远在交替的不停的执行的。
         */
        new Thread(r1).start();
        new Thread(r2).start();
        new Thread(r3).start();

    }
}

```

#### 2.写一个体现可重入思想的例子

```java
/**
 * 写一个体现可重入锁思想的例子
 */
public class ReenLockExample {
    public  synchronized void sendMessage(){
        System.out.println(Thread.currentThread().getName()+" 发送消息");
    }
    public  synchronized void sendEmail(){
        System.out.println(Thread.currentThread().getName()+" 发送邮件");
    }

    public static void main(String[] args) {
        ReenLockExample example = new ReenLockExample();
        ExecutorService service = new ThreadPoolExecutor(2,2,0, TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(), Executors.defaultThreadFactory());
        /**
         * 这样的写法没有体现可重入，因为线程的特点是：可能在你执行的任何一步，都会进行切换。
         * 在这个例子里面，第一个获取到锁对象的线程，执行完sendMessage之后释放，在执行sendEmail之前就切出去了，
         * 另一个线程获取到锁，执行sendMessage。
         */
        Runnable r = () -> {
            example.sendMessage();
            example.sendEmail();
        };
        service.submit(r);
        service.submit(r);
    }
}

//结果
pool-1-thread-1 发送消息
pool-1-thread-2 发送消息
pool-1-thread-2 发送邮件
pool-1-thread-1 发送邮件
```

下面是正确写法

```java
/**
 * 写一个体现可重入锁思想的例子
 */
public class ReenLockExample {
    public  synchronized void sendMessage(){
        System.out.println(Thread.currentThread().getName()+" 发送消息");
        sendEmail();
    }
    public  synchronized void sendEmail(){
        System.out.println(Thread.currentThread().getName()+" 发送邮件");
    }

    public static void main(String[] args) {
        ReenLockExample example = new ReenLockExample();
        ExecutorService service = new ThreadPoolExecutor(2,2,0, TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(), Executors.defaultThreadFactory());
        Runnable r = () -> {
            example.sendMessage();
        };
        service.submit(r);
        service.submit(r);
    }
}

pool-1-thread-1 发送消息
pool-1-thread-1 发送邮件
pool-1-thread-2 发送消息
pool-1-thread-2 发送邮件

```
