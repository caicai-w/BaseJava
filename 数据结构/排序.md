### 1.快速排序

```java
    public static void main(String[] args) {
        int[] a={3,1,4,5,2,10,3,5};
        quickSort(a,0,a.length-1);
        System.out.println(Arrays.toString(a));
    }
    public static void quickSort(int[] a,int low,int high){
        if (low<high){
            int p = partition(a,low,high);
            quickSort(a,low,p-1);
            quickSort(a,p+1,high);
        }
    }
    public static int partition(int[] a,int low,int high){
        int p = a[low];
        while (low<high) {
            while (high > low && a[high] >= p) {
                high--;
            }
            a[low] = a[high];
            while (high > low && a[low] <= p) {
                low++;
            }
            a[high] = a[low];
        }
        a[low]=p;
        return low;

    }
```

### 2.堆排序
```java
public class HeapSort {
    public static void main(String[] args) {
        int[] tree = {4,10,3,5,1,2};
        build_heap(tree);
        //到此建堆完成，接下来是用堆来排序
        //思路：把堆从从堆顶和最后一个交换位置
        for (int i=tree.length-1;i>=0;i--){
            //第0个位置的一定是堆的最大值，所以把第0个元素先换到最后，所以就是把最大值放到了最后
            swap(tree,i,0);
            heap(tree,i-1,0);
        }
        for (int s:tree){
            System.out.println(s);
        }
    }

    /**
     * 思路：每次把堆的第一个和最后一个做交换，
     */
    public static void build_heap(int[] tree){
        int n  = tree.length-1;
        for (int i=(n-1)/2;i>=0;i--){
            heap(tree,n,i);
        }
    }
    /**
     * 第i个节点开始向下调整，一直调整到最后一个节点
     */
    public static void heap(int[] tree,int n,int i){
        //递归结束,第i个节点已经到了第n个节点，就结束
        if (i>=n){
            return;
        }
        //记录第 i 个节点的两个孩子
        int c1 = i * 2+1;
        int c2 = i * 2+2;
        int max = i;
        //现在第i个节点就是父节点，找c1和c2里面最大的和i做交换
        if (c1 <= n && tree[c1] > tree[max]){
            max = c1;
        }
        if (c2 <= n && tree[c2] > tree[max]){
            max = c2;
        }
        //如果最大的是它的孩子中的一个，那么就要做交换，也就是max 要不等于c1，要不等于c2
        if (max!=i){
            /**
             * 交换完之后，继续调整，递归调用
             * swap是只会交换下表为max和i的元素里面的内容，不会对下标产生修改
             */
            swap(tree,max,i);
            heap(tree,n,max);
        }
    }
    private static void swap(int[] tree,int max,int i){
        int t = tree[max];
        tree[max] = tree[i];
        tree[i] = t;
    }
}

```
