### 1.[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/submissions/)

输入: "babad"
输出: "bab"，注意: "aba" 也是一个有效答案。
思路：中心扩展法。
```java
class Solution {
    public String longestPalindrome(String s) {
        if(s==null || s.length()<1){
            return "";
        }
        //中心扩展法
        int len = s.length();
        int start = 0;
        int end = 0;
        for(int i=0;i<len;i++){
           int p = size(s,i,i);
           int p1 = size(s,i,i+1);
            //这道题里面，没有必要做p和p1的区分，因为都是对下标是i的操作
           int max = Math.max(p,p1);
           if(max>end-start){
               start = i-(max-1)/2;
               end = i+max/2;
           }
            
        }
        return s.substring(start,end+1);
    }
    private int size(String s,int L,int R){
        int len = s.length();
       while( L>=0 && R <len && s.charAt(L) == s.charAt(R)){
           --L;
           ++R;
       }
        //为什么-1，不为什么，问就是试出来的
        return R-L-1;
        
    }
}
```

### 2.[整数反转](https://leetcode-cn.com/problems/reverse-integer/)
输入: 123
输出: 321
```java
    public int reverse(int x) {
        long res = 0;
        while(x!=0){
            int t = x%10;
            res = res*10+t;
            x/=10;
        }
        if(res<Math.pow(-2,31) || res>Math.pow(2,31)-1){
            return 0;
        }
        return (int)res;  
    }
```

### 3.[反转字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)
```java
//"Let's take LeetCode contest"
//"s'teL ekat edoCteeL tsetnoc"

public String reverseWords(String s) {
      String[] str = s.split(" ");
        StringBuilder stringBuilder = new StringBuilder();
        for (int i=0;i<str.length;i++){
            StringBuilder t = new StringBuilder(str[i]);
            stringBuilder.append(t.reverse().append(" "));
        }
        return stringBuilder.toString().trim();
    }
```
### 4. [除自身以外的数组乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

输入: [1,2,3,4]
输出: [24,12,8,6]
```java
  public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];
        //每一个数字左边的乘积
        int k=1;
        for (int i=0;i<len;i++){
            //第一个数字，设置1，
            res[i]=k;
            k=k*nums[i];
        }
        k=1;
        for (int j=len-1;j>=0;j--){
            res[j]=res[j]*k;
            k*=nums[j];
        }
        return res;
    }
```

### 5.[删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)
```java
```
### 6.[二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
```java
 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return null;
        }
        //递归先写结束条件
        if(root.val>p.val && root.val<q.val){
            return root;
        }
        //如果root的比两个都小，说明root不够靠右
        if(root.val<p.val && root.val<q.val){
           return lowestCommonAncestor(root.right,p,q);
        }
        //如果root的比两个都大，说明root不够靠左
        if(root.val>p.val && root.val>q.val){
           return lowestCommonAncestor(root.left,p,q);
        }
        return root;
    }
```
### 7.[2的幂](https://leetcode-cn.com/problems/power-of-two/)
```java
//任何2的幂次，二进制都是1开头后面都是0
//   2的幂次-1，二进制都是0开头，后面都是1，做与运算一定是0
public boolean isPowerOfTwo(int n) {
        return n>0 && (n&(n-1))==0;
 }
```
### 8.[二叉搜索树中第k小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)
```java

```
